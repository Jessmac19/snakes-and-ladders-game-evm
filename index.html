<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="üêç Epic multiplayer Snakes & Ladders game with stunning animations, epic sound effects, blockchain integration, and real-time multiplayer. Play with friends online!">
    <meta name="keywords" content="snakes and ladders, multiplayer game, blockchain, web3, gaming, online game, board game">
    <meta name="author" content="Multisynq Snakes & Ladders">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="üêç Multisynq Snakes & Ladders ü™ú - Play Online">
    <meta property="og:description" content="The ultimate Snakes & Ladders experience with epic animations, sound effects, and multiplayer gameplay!">
    <meta property="og:image" content="https://your-username.github.io/snakes-and-ladders-game/game-preview.png">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:title" content="üêç Multisynq Snakes & Ladders ü™ú">
    <meta property="twitter:description" content="Epic multiplayer Snakes & Ladders with stunning effects!">
    
    <title>üêç Multisynq Snakes & Ladders ü™ú - Play Online with Friends</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üéÆ</text></svg>">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Inter:wght@300;400;500;600;700&display=swap');
        
        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #111111;
            --bg-tertiary: #1a1a1a;
            --accent-purple: #8b5cf6;
            --accent-blue: #06b6d4;
            --accent-green: #10b981;
            --accent-orange: #f59e0b;
            --accent-red: #ef4444;
            --text-primary: #ffffff;
            --text-secondary: #a1a1aa;
            --border-color: #27272a;
            --glow-color: rgba(139, 92, 246, 0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            background-image: 
                radial-gradient(circle at 20% 50%, rgba(139, 92, 246, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(6, 182, 212, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(16, 185, 129, 0.1) 0%, transparent 50%);
        }

        .app-container {
            display: grid;
            grid-template-areas: 
                "header header header"
                "sidebar board main";
            grid-template-columns: 320px 1fr 380px;
            grid-template-rows: 80px 1fr;
            height: 100vh;
            gap: 2px;
            background: var(--border-color);
            padding: 2px;
        }

        .header {
            grid-area: header;
            background: linear-gradient(135deg, var(--bg-primary), var(--bg-secondary));
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 2rem;
            border-bottom: 2px solid var(--border-color);
            border-radius: 12px 12px 0 0;
            position: relative;
            z-index: 100;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            animation: headerShine 4s infinite;
        }

        @keyframes headerShine {
            0% { left: -100%; }
            50% { left: 100%; }
            100% { left: 100%; }
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .header-controls {
            display: flex;
            gap: 1rem;
            flex: 1;
            justify-content: center;
        }

        .header-btn {
            background: linear-gradient(135deg, var(--bg-tertiary), var(--bg-primary));
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 0.75rem 1.5rem;
            border-radius: 25px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            position: relative;
            z-index: 10;
            pointer-events: auto;
        }

        .header-btn:hover {
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue));
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(139, 92, 246, 0.3);
        }

        .header-btn:active {
            transform: translateY(0);
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .status-badge {
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .status-badge.online {
            background: rgba(16, 185, 129, 0.2);
            color: var(--accent-green);
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        .status-badge.offline {
            background: rgba(239, 68, 68, 0.2);
            color: var(--accent-red);
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .wallet-info {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .sidebar {
            grid-area: sidebar;
            background: var(--bg-secondary);
            padding: 1.5rem;
            overflow-y: auto;
            border-right: 1px solid var(--border-color);
        }

        .main-controls {
            grid-area: main;
            background: linear-gradient(135deg, var(--bg-secondary), var(--bg-tertiary));
            padding: 2rem;
            overflow-y: auto;
            border-radius: 12px;
            border: 2px solid var(--border-color);
        }

        .board-area {
            grid-area: board;
            background: linear-gradient(135deg, var(--bg-primary), var(--bg-secondary));
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 12px;
            border: 2px solid var(--border-color);
            overflow: hidden;
            position: relative;
        }

        .board-area::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 50% 50%, rgba(139, 92, 246, 0.1) 0%, transparent 70%);
            pointer-events: none;
        }

        .section {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            position: relative;
            overflow: hidden;
        }

        .section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, var(--accent-purple), var(--accent-blue), var(--accent-green));
        }

        .section-title {
            font-size: 0.875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .dice-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            padding: 2rem 0;
        }

        .dice-3d {
            width: 100px;
            height: 100px;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            margin: 1rem 0;
        }

        .dice-face {
            position: absolute;
            width: 100px;
            height: 100px;
            background: linear-gradient(135deg, #ffffff, #f3f4f6);
            border: 3px solid var(--accent-purple);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: bold;
            color: var(--bg-primary);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .dice-face.front  { transform: translateZ(50px); }
        .dice-face.back   { transform: rotateY(180deg) translateZ(50px); }
        .dice-face.right  { transform: rotateY(90deg) translateZ(50px); }
        .dice-face.left   { transform: rotateY(-90deg) translateZ(50px); }
        .dice-face.top    { transform: rotateX(90deg) translateZ(50px); }
        .dice-face.bottom { transform: rotateX(-90deg) translateZ(50px); }

        .dice-rolling {
            animation: diceRoll 2s ease-in-out infinite;
        }

        @keyframes diceRoll {
            0% { transform: rotateX(0deg) rotateY(0deg); }
            25% { transform: rotateX(90deg) rotateY(90deg); }
            50% { transform: rotateX(180deg) rotateY(180deg); }
            75% { transform: rotateX(270deg) rotateY(270deg); }
            100% { transform: rotateX(360deg) rotateY(360deg); }
        }

        .btn {
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue));
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-size: 0.875rem;
            width: 100%;
            margin: 0.25rem 0;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px var(--glow-color);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn.primary {
            background: linear-gradient(135deg, var(--accent-orange), var(--accent-red));
            font-size: 1rem;
            padding: 1rem 2rem;
            border-radius: 12px;
            font-weight: 700;
        }

        .btn.success {
            background: linear-gradient(135deg, var(--accent-green), var(--accent-blue));
        }

        .player-card {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            margin: 0.5rem 0;
            transition: all 0.3s ease;
            position: relative;
        }

        .player-card.current {
            border-color: var(--accent-purple);
            box-shadow: 0 0 20px var(--glow-color);
        }

        .player-card.current::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            background: linear-gradient(45deg, var(--accent-purple), var(--accent-blue), var(--accent-green), var(--accent-orange));
            border-radius: 8px;
            z-index: -1;
            animation: borderGlow 2s linear infinite;
        }

        @keyframes borderGlow {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .player-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 1rem;
            border: 2px solid var(--accent-purple);
        }

        .player-1 { background: linear-gradient(135deg, var(--accent-red), var(--accent-orange)); }
        .player-2 { background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple)); }
        .player-3 { background: linear-gradient(135deg, var(--accent-green), var(--accent-blue)); }
        .player-4 { background: linear-gradient(135deg, var(--accent-orange), var(--accent-red)); }

        .game-board-modern {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 3px;
            background: radial-gradient(circle at center, #0a0a1e, #000016);
            padding: 2rem;
            border-radius: 20px;
            border: 3px solid #00d4ff;
            max-width: 500px;
            width: 100%;
            position: relative;
            box-shadow: 
                0 0 30px rgba(0, 212, 255, 0.3),
                0 20px 40px rgba(0, 0, 0, 0.7),
                inset 0 0 50px rgba(0, 212, 255, 0.05);
            animation: boardPulse 3s ease-in-out infinite alternate;
        }

        @keyframes boardPulse {
            from { 
                border-color: #00d4ff;
                box-shadow: 
                    0 0 30px rgba(0, 212, 255, 0.3),
                    0 20px 40px rgba(0, 0, 0, 0.7),
                    inset 0 0 50px rgba(0, 212, 255, 0.05);
            }
            to { 
                border-color: #00ff88;
                box-shadow: 
                    0 0 40px rgba(0, 255, 136, 0.5),
                    0 20px 40px rgba(0, 0, 0, 0.7),
                    inset 0 0 60px rgba(0, 255, 136, 0.08);
            }
        }

        .board-cell-modern {
            aspect-ratio: 1;
            background: linear-gradient(145deg, #1a1a2e, #16213e);
            border: 2px solid #0f3460;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.8rem;
            position: relative;
            transition: all 0.3s ease;
            color: #00d4ff;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
            box-shadow: inset 0 0 10px rgba(0, 212, 255, 0.1);
        }

        .board-cell-modern:hover {
            transform: scale(1.05);
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.4), inset 0 0 15px rgba(0, 255, 136, 0.1);
            color: #00ff88;
            text-shadow: 0 0 15px rgba(0, 255, 136, 0.8);
        }

        .board-cell-modern.snake {
            background: linear-gradient(135deg, #ff1744, #d50000);
            border-color: #ff1744;
            color: white;
            text-shadow: 0 0 10px rgba(255, 23, 68, 0.8);
            box-shadow: 0 0 15px rgba(255, 23, 68, 0.3), inset 0 0 10px rgba(255, 255, 255, 0.1);
            animation: snakeCellGlow 2s ease-in-out infinite alternate;
        }

        .board-cell-modern.ladder {
            background: linear-gradient(135deg, #00e676, #00c853);
            border-color: #00e676;
            color: white;
            text-shadow: 0 0 10px rgba(0, 230, 118, 0.8);
            box-shadow: 0 0 15px rgba(0, 230, 118, 0.3), inset 0 0 10px rgba(255, 255, 255, 0.1);
            animation: ladderCellGlow 2s ease-in-out infinite alternate;
        }

        .board-cell-modern.finish {
            background: linear-gradient(135deg, #ffc107, #ff8f00);
            border-color: #ffc107;
            color: white;
            font-weight: 900;
            text-shadow: 0 0 15px rgba(255, 193, 7, 1);
            box-shadow: 0 0 25px rgba(255, 193, 7, 0.5), inset 0 0 15px rgba(255, 255, 255, 0.2);
            animation: finishGlow 1.5s ease-in-out infinite;
        }

        @keyframes finishGlow {
            0%, 100% { 
                box-shadow: 0 0 25px rgba(255, 193, 7, 0.5), inset 0 0 15px rgba(255, 255, 255, 0.2);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 40px rgba(255, 193, 7, 0.9), inset 0 0 20px rgba(255, 255, 255, 0.3);
                transform: scale(1.02);
            }
        }

        @keyframes snakeCellGlow {
            from { box-shadow: 0 0 15px rgba(255, 23, 68, 0.3), inset 0 0 10px rgba(255, 255, 255, 0.1); }
            to { box-shadow: 0 0 25px rgba(255, 23, 68, 0.6), inset 0 0 15px rgba(255, 255, 255, 0.2); }
        }

        @keyframes ladderCellGlow {
            from { box-shadow: 0 0 15px rgba(0, 230, 118, 0.3), inset 0 0 10px rgba(255, 255, 255, 0.1); }
            to { box-shadow: 0 0 25px rgba(0, 230, 118, 0.6), inset 0 0 15px rgba(255, 255, 255, 0.2); }
        }

        .terminal {
            background: var(--bg-primary);
            border-radius: 8px;
            padding: 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
        }

        .terminal-line {
            margin: 0.25rem 0;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            animation: fadeInUp 0.3s ease;
        }

        .terminal-line:hover {
            background: rgba(139, 92, 246, 0.1);
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .glass-effect {
            background: rgba(26, 26, 26, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .neon-text {
            text-shadow: 0 0 10px var(--accent-purple), 0 0 20px var(--accent-purple), 0 0 30px var(--accent-purple);
        }

        .floating-icon {
            position: absolute;
            font-size: 1.5rem;
            opacity: 0.1;
            animation: float 6s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-20px); }
        }
        
        /* üì± Mobile notification animations */
        @keyframes slideInFromTop {
            from {
                transform: translate(-50%, -100%);
                opacity: 0;
            }
            to {
                transform: translate(-50%, 0);
                opacity: 1;
            }
        }
        
        @keyframes slideOutToTop {
            from {
                transform: translate(-50%, 0);
                opacity: 1;
            }
            to {
                transform: translate(-50%, -100%);
                opacity: 0;
            }
        }
        
        /* Mobile-specific styles */
        .mobile-optimized .game-board {
            touch-action: pan-x pan-y;
        }
        
        .mobile-optimized .dice-3d {
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
        
        .mobile-notification {
            pointer-events: none;
            user-select: none;
        }
        
        .mobile-notification.success {
            border-color: var(--accent-green);
            background: linear-gradient(135deg, var(--bg-secondary), var(--accent-green));
        }
        
        .mobile-notification.error {
            border-color: var(--accent-red);
            background: linear-gradient(135deg, var(--bg-secondary), var(--accent-red));
        }
        
        /* Board zoom styles */
        .game-board.zoomed {
            transition: transform 0.3s ease-in-out;
            overflow: visible;
        }
        
        /* üé™ Advanced Animation Styles */
        @keyframes snakeSlither {
            0%, 100% { transform: translate(-50%, -50%) rotate(0deg) scale(1); }
            25% { transform: translate(-50%, -50%) rotate(-5deg) scale(1.1); }
            50% { transform: translate(-50%, -50%) rotate(0deg) scale(1); }
            75% { transform: translate(-50%, -50%) rotate(5deg) scale(1.1); }
        }
        
        @keyframes ladderSparkle {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
        }
        
        @keyframes trailPulse {
            0%, 100% { opacity: 1; transform: scaleY(1); }
            50% { opacity: 0.6; transform: scaleY(0.8); }
        }
        
        @keyframes floatRandom {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(10px, -15px) rotate(90deg); }
            50% { transform: translate(-5px, -25px) rotate(180deg); }
            75% { transform: translate(-15px, -10px) rotate(270deg); }
        }
        
        @keyframes rainFall {
            0% { transform: translateY(-100vh) rotate(10deg); }
            100% { transform: translateY(100vh) rotate(10deg); }
        }
        
        @keyframes snowFall {
            0% { transform: translateY(-100vh) rotate(0deg); }
            100% { transform: translateY(100vh) rotate(360deg); }
        }
        
        @keyframes starTwinkle {
            0%, 100% { opacity: 0.3; transform: scale(0.8); }
            50% { opacity: 1; transform: scale(1.2); }
        }
        
        @keyframes emoteFloat {
            0% { transform: translate(-50%, -100%) scale(0.5); opacity: 0; }
            20% { transform: translate(-50%, -120%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -200%) scale(1); opacity: 0; }
        }
        
        /* Animation containers */
        .player-trail {
            will-change: transform, opacity;
        }
        
        .animated-snake, .animated-ladder {
            will-change: transform;
            cursor: pointer;
        }
        
        .animated-snake:hover {
            transform: translate(-50%, -50%) scale(1.2);
            filter: drop-shadow(0 0 20px rgba(239, 68, 68, 0.8));
        }
        
        .animated-ladder:hover {
            transform: translate(-50%, -50%) scale(1.2);
            filter: drop-shadow(0 0 20px rgba(16, 185, 129, 0.8));
        }
        
        .floating-particles {
            will-change: transform;
        }
        
        .floating-particle {
            will-change: transform, opacity;
        }
        
        .weather-effects {
            will-change: transform;
        }
        
        .emote-panel {
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .emote-btn:hover {
            border-color: var(--accent-purple);
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(139, 92, 246, 0.4);
        }
        
        .board-emote {
            will-change: transform, opacity;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        
        @keyframes bounceIn {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.05); }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); opacity: 1; }
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--bg-primary);
            border-radius: 6px;
            font-size: 0.875rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .status-dot.online {
            background: var(--accent-green);
            box-shadow: 0 0 10px var(--accent-green);
        }

        .status-dot.offline {
            background: var(--accent-red);
            box-shadow: 0 0 10px var(--accent-red);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin: 1rem 0;
        }

        .stat-card {
            background: var(--bg-primary);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-purple);
        }

        .stat-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .app-container {
                grid-template-columns: 260px 1fr 1fr;
            }
        }

        @media (max-width: 900px) {
            .app-container {
                grid-template-areas: 
                    "header header header"
                    "sidebar board board"
                    "main main main";
                grid-template-columns: 1fr 1fr 1fr;
                grid-template-rows: 80px 1fr 1fr;
            }
        }

        /* üì± MOBILE OPTIMIZATION */
        /* Touch-friendly controls */
        @media (max-width: 768px) {
            .btn {
                min-height: 48px;
                font-size: 1rem;
                padding: 1rem 1.5rem;
                touch-action: manipulation;
            }
            
            .room-input {
                min-height: 48px;
                font-size: 1.1rem;
            }
            
            /* Larger touch targets */
            .dice-3d {
                transform: scale(1.2);
                margin: 2rem auto;
            }
            
            /* Better modal experience on mobile */
            .modal-content {
                margin: 1rem;
                max-height: 90vh;
                overflow-y: auto;
                border-radius: 15px;
            }
            
            .modal-header {
                position: sticky;
                top: 0;
                background: var(--bg-secondary);
                z-index: 10;
                border-radius: 15px 15px 0 0;
            }
            
            /* Mobile board optimization */
            .game-board {
                padding: 0.5rem;
                overflow: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .board-cell {
                min-width: 40px;
                min-height: 40px;
                font-size: 0.8rem;
            }
            
            /* Swipe gestures support */
            .swipe-area {
                touch-action: pan-x pan-y;
            }
            
            /* Better header controls for mobile */
            .header-controls {
                gap: 0.5rem;
            }
            
            .header-btn {
                padding: 0.6rem 1rem;
                font-size: 0.9rem;
                min-width: 44px;
                min-height: 44px;
            }
            
            /* Mobile lobby improvements */
            .lobby-player {
                padding: 1.2rem;
            }
            
            .player-avatar {
                font-size: 2rem;
            }
            
            /* Better input experience */
            input[type="text"], input[type="range"] {
                font-size: 16px; /* Prevents zoom on iOS */
            }
            
            /* Enhanced touch feedback */
            .btn:active, .header-btn:active {
                transform: scale(0.95);
                transition: transform 0.1s ease;
            }
        }
        
        /* Tablet optimization */
        @media (min-width: 769px) and (max-width: 1024px) {
            .app-container {
                grid-template-columns: 320px 1fr 1fr;
            }
            
            .btn {
                min-height: 44px;
            }
            
            .modal-content {
                max-width: 600px;
            }
        }
        
        /* Ultra-wide mobile landscape */
        @media (max-width: 900px) and (orientation: landscape) {
            .app-container {
                grid-template-areas: 
                    "header header header"
                    "sidebar board main";
                grid-template-columns: 280px 1fr 1fr;
                grid-template-rows: 60px 1fr;
            }
            
            .dice-3d {
                transform: scale(0.9);
            }
            
            .modal-content {
                max-height: 80vh;
            }
        }
        
        /* Accessibility improvements */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        /* High contrast mode support */
        @media (prefers-contrast: high) {
            :root {
                --border-color: #ffffff;
                --text-secondary: #ffffff;
            }
        }
        
        /* Dark mode support (if system preference) */
        @media (prefers-color-scheme: dark) {
            :root {
                --bg-primary: #000000;
                --text-primary: #ffffff;
            }
        }

        /* üéµ Audio Panel Styles */
        .audio-panel {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .audio-panel h3 {
            color: var(--text-primary);
            margin: 0 0 1rem 0;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .audio-control {
            margin-bottom: 1rem;
        }

        .audio-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            color: var(--text-secondary);
            transition: color 0.3s;
        }

        .audio-toggle:hover {
            color: var(--text-primary);
        }

        .audio-toggle input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--accent-purple);
        }

        .audio-control label {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            display: block;
        }

        .audio-control input[type="range"] {
            width: 100%;
            height: 6px;
            background: var(--bg-primary);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        .audio-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--accent-purple);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(139, 92, 246, 0.3);
        }

        .audio-control input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--accent-purple);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(139, 92, 246, 0.3);
        }

        /* üé™ Particle Animation Styles */
        #particleContainer {
            pointer-events: none;
        }

        .particle {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
        }

        /* üìä Stats Panel Styles */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-item {
            text-align: center;
            padding: 8px;
            background: var(--bg-primary);
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--accent-purple);
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .achievement {
            padding: 4px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .achievement:last-child {
            border-bottom: none;
        }

        /* üé® Avatar Selection Styles */
        .avatar-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(139, 92, 246, 0.5);
        }

        /* ÔøΩ Enhanced Multiplayer Styles */
        .room-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .room-info-panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1rem 0;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        
        .room-header {
            text-align: center;
            margin-bottom: 1.5rem;
        }
        
        .room-code {
            background: var(--accent-purple);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-family: 'JetBrains Mono', monospace;
            font-weight: bold;
            letter-spacing: 0.1em;
        }
        
        .room-status {
            margin-top: 0.5rem;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
        
        .status-waiting { color: var(--accent-orange); }
        .status-ready { color: var(--accent-green); }
        .status-playing { color: var(--accent-blue); }
        
        .lobby-container {
            margin: 1.5rem 0;
        }
        
        .lobby-container h5 {
            color: var(--accent-blue);
            margin-bottom: 1rem;
            font-size: 1rem;
        }
        
        .lobby-players {
            display: grid;
            gap: 0.8rem;
        }
        
        .lobby-player {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--bg-tertiary);
            padding: 1rem;
            border-radius: 10px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        
        .lobby-player.ready {
            border-color: var(--accent-green);
            box-shadow: 0 0 10px rgba(16, 185, 129, 0.2);
        }
        
        .lobby-player.host {
            border-color: var(--accent-purple);
            box-shadow: 0 0 10px rgba(139, 92, 246, 0.2);
        }
        
        .player-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .player-avatar {
            font-size: 1.5rem;
        }
        
        .player-name {
            font-weight: 600;
        }
        
        .player-address {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        
        .player-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }
        
        .status-badge {
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
        }
        
        .status-badge.ready {
            background: var(--accent-green);
            color: white;
        }
        
        .status-badge.waiting {
            background: var(--accent-orange);
            color: white;
        }
        
        .status-badge.host {
            background: var(--accent-purple);
            color: white;
        }
        
        .ready-system {
            text-align: center;
            margin: 1.5rem 0;
        }
        
        .ready-btn {
            margin-bottom: 1rem;
            min-width: 150px;
        }
        
        .ready-btn.active {
            background: var(--accent-green);
            border-color: var(--accent-green);
        }
        
        .ready-indicator {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
        
        .join-room-section {
            margin: 1.5rem 0;
        }
        
        .input-group {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        
        .room-input {
            flex: 1;
            padding: 1rem;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            text-align: center;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            transition: all 0.3s ease;
        }
        
        .room-input:focus {
            outline: none;
            border-color: var(--accent-purple);
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.3);
        }
        
        .spectator-option {
            text-align: center;
            margin: 1rem 0;
        }
        
        .game-status {
            margin-top: 1.5rem;
            text-align: center;
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.8rem;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 10px;
            border: 1px solid var(--border-color);
        }
        
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent-red);
            animation: pulse 2s infinite;
        }
        
        .status-dot.connected {
            background: var(--accent-green);
        }
        
        .status-dot.ready {
            background: var(--accent-blue);
        }
        
        /* üé≤ Dice History Styles */
        .dice-history-container {
            margin-top: 1.5rem;
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 1rem;
        }
        
        .dice-history-container h5 {
            color: var(--accent-blue);
            margin-bottom: 1rem;
            font-size: 0.9rem;
        }
        
        .dice-history {
            max-height: 150px;
            overflow-y: auto;
        }
        
        .history-placeholder {
            text-align: center;
            color: var(--text-secondary);
            font-style: italic;
            padding: 1rem;
        }
        
        .history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
            border-left: 4px solid var(--accent-purple);
        }
        
        .history-player {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .history-roll {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--accent-green);
        }
        
        .history-time {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        
        /* ‚è∞ Turn Indicator Styles */
        .turn-indicator {
            background: var(--bg-secondary);
            border: 2px solid var(--accent-blue);
            border-radius: 10px;
            padding: 1rem;
            margin-top: 1rem;
            text-align: center;
        }
        
        .turn-info {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }
        
        .turn-timer {
            width: 100%;
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            overflow: hidden;
        }
        
        .timer-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-green), var(--accent-orange), var(--accent-red));
            border-radius: 3px;
            transition: width 1s linear;
        }

        /* ÔøΩüåü Modal Popup Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: linear-gradient(135deg, var(--bg-secondary), var(--bg-tertiary));
            border: 2px solid var(--accent-purple);
            border-radius: 20px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            transform: scale(0.8) translateY(50px);
            transition: all 0.3s ease;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .modal-overlay.active .modal-content {
            transform: scale(1) translateY(0);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent-purple);
            margin: 0;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 50%;
            transition: all 0.3s ease;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            background: var(--accent-red);
            color: white;
            transform: rotate(90deg);
        }

        .modal-section {
            margin-bottom: 1.5rem;
        }

        .modal-section h4 {
            color: var(--accent-blue);
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .control-group {
            margin-bottom: 1rem;
        }

        .control-label {
            display: block;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .control-input {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 1rem;
        }

        .control-input:focus {
            border-color: var(--accent-purple);
            outline: none;
            box-shadow: 0 0 10px rgba(139, 92, 246, 0.3);
        }

        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 8px;
            transition: background 0.3s ease;
        }

        .toggle-switch:hover {
            background: var(--bg-primary);
        }

        .toggle-switch input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: var(--accent-purple);
        }

        .avatar-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            margin-top: 1rem;
        }

        .avatar-option {
            padding: 1rem;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .avatar-option:hover {
            transform: scale(1.1);
            border-color: var(--accent-purple);
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.5);
        }

        .avatar-option.selected {
            border-color: var(--accent-purple);
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue));
            box-shadow: 0 0 30px rgba(139, 92, 246, 0.7);
        }

        .theme-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-top: 1rem;
        }

        .theme-option {
            padding: 1rem;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .theme-option:hover {
            border-color: var(--accent-purple);
            transform: translateY(-2px);
        }

        .theme-option.selected {
            border-color: var(--accent-purple);
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue));
        }

        .stats-grid-modal {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .stat-card {
            background: var(--bg-primary);
            padding: 1.5rem;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            text-align: center;
        }

        .stat-value-large {
            font-size: 2rem;
            font-weight: bold;
            color: var(--accent-purple);
            margin-bottom: 0.5rem;
        }

        .stat-label-large {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .achievement-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .achievement-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.75rem;
            background: var(--bg-primary);
            border-radius: 8px;
            margin-bottom: 0.5rem;
            border-left: 4px solid var(--border-color);
            transition: all 0.3s ease;
        }

        .achievement-item.unlocked {
            border-left-color: var(--accent-green);
            background: linear-gradient(90deg, var(--bg-primary), rgba(16, 185, 129, 0.1));
        }

        .achievement-icon {
            font-size: 1.5rem;
        }

        .achievement-details h5 {
            margin: 0 0 0.25rem 0;
            color: var(--text-primary);
        }

        .achievement-details p {
            margin: 0;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <div class="header-left">
                <div class="logo">‚ö°Monad SNAKES</div>
                <div class="status-badge online" id="gameStatus">READY</div>
            </div>
            
            <!-- üåü NEW: Top Banner Controls -->
            <div class="header-controls">
                <button class="header-btn" id="audioControlBtn" title="Audio Controls">
                    üéµ Audio
                </button>
                <button class="header-btn" id="customizationBtn" title="Customization">
                    üé® Themes
                </button>
                <button class="header-btn" id="statisticsBtn" title="Statistics">
                    üèÜ Stats
                </button>
                <button class="header-btn" id="settingsBtn" title="Settings">
                    ‚öôÔ∏è Settings
                </button>
                <button class="header-btn" id="aiBotBtn" title="Add AI Bot for Solo Play">
                    ü§ñ AI Bot
                </button>
            </div>
            
            <div class="header-right">
                <div class="connection-status">
                    <div class="status-dot offline" id="multisynqDot"></div>
                    <span id="multisynqStatusText">Connecting...</span>
                </div>
                <div class="wallet-info" id="walletDisplay">No wallet connected</div>
            </div>
        </header>

        <!-- Sidebar -->
        <aside class="sidebar">
            <!-- Connection Section -->
            <div class="section">
                <h3 class="section-title">üîó CONNECTION</h3>
                <button id="connectWalletBtn" class="btn">Connect MetaMask</button>
                <button id="connectMultisynqBtn" class="btn">Connect Multisynq</button>
                
                <div class="connection-status" style="margin-top: 1rem;">
                    <div class="status-dot offline" id="walletDot"></div>
                    <span id="walletStatusText">Wallet Disconnected</span>
                </div>
            </div>

            <!-- Players Section -->
            <div class="section">
                <h3 class="section-title">üë• PLAYERS</h3>
                <div id="playersContainer">
                    <div style="text-align: center; color: var(--text-secondary); padding: 1rem 0;">
                        No players connected
                    </div>
                </div>
            </div>

            <!-- Room Code Section -->
            <div class="section">
                <h3 class="section-title">üéØ ROOM CODE</h3>
                <div id="roomCodeDisplay" style="text-align: center; margin: 1rem 0; padding: 1rem; background: rgba(139, 92, 246, 0.1); border-radius: 8px; display: none;">
                    <div style="font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 0.5rem;">Your Room Code:</div>
                    <div id="roomCodeText" style="font-size: 1.5rem; font-weight: 700; color: var(--accent-purple); letter-spacing: 0.2em;"></div>
                    <div style="font-size: 0.7rem; color: var(--text-secondary); margin-top: 0.5rem;">Share with friends to play together!</div>
                </div>
                
                <div id="joinRoomSection">
                    <input type="text" id="roomCodeInput" placeholder="Enter room code (e.g. ABC123)" maxlength="6" 
                           style="width: 100%; padding: 0.75rem; margin: 0.5rem 0; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-primary); font-size: 0.875rem; text-transform: uppercase; text-align: center; letter-spacing: 0.1em;">
                    <button id="joinRoomBtn" class="btn">Join Friend's Room</button>
                    <button id="createRoomBtn" class="btn success">Create New Room</button>
                </div>
                
                <div id="roomInfo" style="margin-top: 1rem; font-size: 0.75rem; color: var(--text-secondary); text-align: center; display: none;">
                    <div id="roomStatusText"></div>
                </div>
            </div>

            <!-- Statistics -->
            <div class="section">
                <h3 class="section-title">üìä STATS</h3>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="totalGames">0</div>
                        <div class="stat-label">Games</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="currentRound">0</div>
                        <div class="stat-label">Round</div>
                    </div>
                </div>
            </div>

            <!-- Gas Costs -->
            <div class="section">
                <h3 class="section-title">üí∞ TRANSACTION COSTS</h3>
                <div style="font-size: 0.75rem; color: var(--text-secondary); line-height: 1.4;">
                    <div style="margin: 0.5rem 0; padding: 0.5rem; background: rgba(139, 92, 246, 0.1); border-radius: 6px;">
                        <strong style="color: var(--accent-orange);">Join Game:</strong> 0.05 MON + gas<br>
                        <span style="font-size: 0.7rem; opacity: 0.8;">~0.01 MON gas (102 Gwei)</span>
                    </div>
                    <div style="margin: 0.5rem 0; padding: 0.5rem; background: rgba(59, 130, 246, 0.1); border-radius: 6px;">
                        <strong style="color: var(--accent-blue);">Each Dice Roll:</strong> 0.0001 MON + gas<br>
                        <span style="font-size: 0.7rem; opacity: 0.8;">~0.01 MON gas per roll</span>
                    </div>
                    <div style="margin: 0.5rem 0; padding: 0.5rem; background: rgba(34, 197, 94, 0.1); border-radius: 6px;">
                        <strong style="color: var(--accent-green);">Total Game Cost:</strong> ~0.15-0.25 MON<br>
                        <span style="font-size: 0.7rem; opacity: 0.8;">Including current network fees</span>
                    </div>
                    <div style="margin: 0.5rem 0; font-size: 0.7rem; opacity: 0.8; text-align: center;">
                        ‚õΩ Current gas: 102 Gwei | Block: #27,172,687<br>
                        üöÄ Game continues locally if transactions fail
                    </div>
                </div>
            </div>
        </aside>

        <!-- Main Controls -->
        <main class="main-controls">
            <!-- Dice Control Section - TOP PRIORITY -->
            <div class="section">
                <h3 class="section-title">üé≤ DICE CONTROL</h3>
                <div class="dice-container">
                    <div class="dice-3d" id="dice3D">
                        <div class="dice-face front">‚öÄ</div>
                        <div class="dice-face back">‚öÅ</div>
                        <div class="dice-face right">‚öÇ</div>
                        <div class="dice-face left">‚öÉ</div>
                        <div class="dice-face top">‚öÑ</div>
                        <div class="dice-face bottom">‚öÖ</div>
                    </div>
                    <button id="rollDiceBtn" class="btn primary" disabled>ROLL DICE</button>
                    <div style="text-align: center; margin: 0.25rem 0;">
                        <label style="color: var(--text-secondary); font-size: 0.75rem;">
                            <input type="checkbox" id="blockchainModeToggle" checked style="margin-right: 0.3rem;">
                            Blockchain Mode
                        </label>
                    </div>
                    <div id="lastRollInfo" style="text-align: center; margin: 0.25rem 0; color: var(--text-secondary); font-size: 0.8rem;">
                        Ready
                    </div>
                </div>
                
                <!-- Player Turn Indicator -->
                <div id="turnIndicator" class="turn-indicator" style="display: none;">
                    <div class="turn-info">
                        <span id="currentTurnPlayer">Your Turn</span>
                        <div class="turn-timer" id="turnTimer">
                            <div class="timer-bar"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Game Actions -->
            <div class="section">
                <h3 class="section-title">üéÆ GAME CONTROLS</h3>
                <button id="joinGameBtn" class="btn success" disabled>JOIN GAME</button>
                <button id="startGameBtn" class="btn primary" disabled>START GAME</button>
                
                <!-- Game Status -->
                <div id="gameStatus" class="game-status">
                    <div class="status-indicator" id="statusIndicator">
                        <span class="status-dot"></span>
                        <span id="statusText">Not Connected</span>
                    </div>
                </div>
            </div>

            <!-- Game Log -->
            <div class="section">
                <h3 class="section-title">üìù GAME LOG</h3>
                <div class="terminal" id="gameTerminal">
                    <div class="terminal-line">üöÄ Ultra Modern Snakes & Ladders initialized</div>
                    <div class="terminal-line">üí´ Multisynq integration ready</div>
                    <div class="terminal-line">‚ö° Connect wallet to begin</div>
                </div>
            </div>
        </main>

        <!-- Board Area -->
        <section class="board-area">
            <div style="width: 100%; margin-bottom: 1rem; background: var(--accent-purple); border: 3px solid var(--accent-purple); border-radius: 15px; padding: 1rem; box-shadow: 0 0 30px var(--accent-purple);">
                <h2 style="font-size: 2.5rem; font-weight: 900; text-align: center; margin: 0; color: white; text-shadow: 0 0 20px white, 0 4px 8px rgba(0,0,0,0.5); letter-spacing: 0.1em;">üéØ GAME BOARD</h2>
                <div style="text-align: center; margin: 0.5rem 0 0 0;">
                    <span id="currentPlayerDisplay" style="font-size: 1.3rem; font-weight: 700; color: white; text-shadow: 0 2px 4px rgba(0,0,0,0.5);">
                        Waiting for players...
                    </span>
                </div>
            </div>
            
            <div class="game-board-modern" id="gameBoardModern">
                <!-- Board will be generated here -->
            </div>

            <!-- Game Info -->
            <div style="text-align: center; margin-top: 1.5rem; color: var(--text-secondary); font-size: 0.875rem;">
                üêç <strong>Snakes:</strong> 17‚Üí7, 54‚Üí34, 98‚Üí79 <br>
                ü™ú <strong>Ladders:</strong> 4‚Üí14, 9‚Üí31, 20‚Üí38
            </div>

            <!-- Floating Icons -->
            <div class="floating-icon" style="top: 10%; left: 10%; animation-delay: 0s;">üéÆ</div>
            <div class="floating-icon" style="top: 20%; right: 15%; animation-delay: 1s;">‚ö°</div>
            <div class="floating-icon" style="bottom: 30%; left: 20%; animation-delay: 2s;">üöÄ</div>
            <div class="floating-icon" style="bottom: 10%; right: 10%; animation-delay: 3s;">üí´</div>
        </section>
    </div>

    <!-- Load external libraries -->
    <script>
        // Simple local multiplayer system without external dependencies
        console.log('Initializing local multiplayer system...');
    </script>
    <script>
        class UltraModernSnakesAndLadders {
            constructor() {
                this.playerAddress = null;
                this.multisynqClient = null;
                this.roomId = null;
                this.players = [];
                this.currentPlayerIndex = 0;
                this.gameStarted = false;
                this.playerPositions = {};
                this.isHost = false;
                this.lastRoll = null;
                this.totalGames = 0;
                this.currentRound = 1;
                
                // Game configuration
                this.SNAKES = { 17: 7, 54: 34, 98: 79 };
                this.LADDERS = { 4: 14, 9: 31, 20: 38 };
                
                // Smart Contract Configuration
                this.contractAddress = "0xed617B0B73Dc514e002F5556F5526cD3640dd992";
                this.contractABI = [
                    {
                        "inputs": [],
                        "name": "rollDice",
                        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                        "stateMutability": "payable",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "joinGame",
                        "outputs": [],
                        "stateMutability": "payable",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "startGame",
                        "outputs": [],
                        "stateMutability": "nonpayable",
                        "type": "function"
                    },
                    {
                        "inputs": [{"internalType": "uint256", "name": "roll", "type": "uint256"}],
                        "name": "submitDiceRoll",
                        "outputs": [],
                        "stateMutability": "nonpayable",
                        "type": "function"
                    }
                ];
                this.contract = null;
                
                // üéµ Audio System
                this.audioContext = null;
                this.sounds = {};
                this.backgroundMusic = null;
                this.soundEnabled = true;
                this.musicEnabled = true;
                this.masterVolume = 0.7;
                
                // üé™ Animation System
                this.particleSystem = null;
                this.animationQueue = [];
                this.cameraPosition = { x: 0, y: 0 };
                this.screenShakeIntensity = 0;
                
                // üé® Customization
                this.playerAvatars = ['ü¶Ñ', 'üêâ', 'ü¶ã', '‚ö°', 'üåü', 'üî•', 'üíé', 'üöÄ'];
                this.currentTheme = 'cyberpunk';
                this.availableThemes = ['cyberpunk', 'classic', 'space', 'medieval'];
                
                // üèÜ Stats & Achievements
                this.playerStats = {
                    gamesPlayed: 0,
                    gamesWon: 0,
                    fastestWin: null,
                    totalDiceRolls: 0,
                    snakesHit: 0,
                    laddersClimbed: 0
                };
                
                this.init();
            }

            async init() {
                this.logToTerminal('üåü Initializing Ultra Modern Game Interface...');
                this.createModernBoard();
                this.logToTerminal('‚úÖ Modern board created');
                
                this.setupEventListeners();
                this.logToTerminal('‚úÖ Event listeners setup');
                
                this.initAudioSystem();
                this.logToTerminal('‚úÖ Audio system initialized');
                
                this.initParticleSystem();
                this.logToTerminal('‚úÖ Particle system initialized');
                
                this.initEnhancedMultiplayer();
                this.logToTerminal('‚úÖ Enhanced multiplayer initialized');
                
                this.initMobileOptimization();
                this.logToTerminal('‚úÖ Mobile optimization initialized');
                
                this.initAdvancedAnimations();
                this.logToTerminal('‚úÖ Advanced animations initialized');
                
                this.initModalSystem();
                this.logToTerminal('‚úÖ Modal system initialized');
                
                this.checkMetaMaskConnection();
                this.logToTerminal('‚úÖ MetaMask connection checked');
                
                this.startConnectionSequence();
                this.logToTerminal('‚úÖ Connection sequence started');
            }

            async checkMetaMaskConnection() {
                if (typeof window.ethereum !== 'undefined') {
                    this.logToTerminal('ü¶ä MetaMask detected!');
                    
                    // Check if already connected
                    try {
                        const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                        if (accounts.length > 0) {
                            this.logToTerminal('üîó Previously connected wallet found');
                            this.playerAddress = accounts[0];
                            
                            // Check network and update UI
                            const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                            if (chainId === '0x279F') {
                                this.logToTerminal('‚úÖ Already on Monad Testnet');
                                // Get balance and update UI
                                try {
                                    const balance = await window.ethereum.request({
                                        method: 'eth_getBalance',
                                        params: [this.playerAddress, 'latest']
                                    });
                                    const balanceInMon = parseInt(balance, 16) / Math.pow(10, 18);
                                    this.updateWalletUI(balanceInMon);
                                    this.logToTerminal('üéÆ Ready to play! Click "Join Game" to start.');
                                } catch (error) {
                                    this.updateWalletUI(0);
                                }
                            } else {
                                this.logToTerminal(`‚ö†Ô∏è Connected to wrong network (${chainId})`);
                                this.logToTerminal('üîÑ Click "Connect MetaMask" to switch networks');
                            }
                        }
                    } catch (error) {
                        this.logToTerminal('‚ÑπÔ∏è No previous connection found');
                    }
                    
                    // Listen for account changes
                    window.ethereum.on('accountsChanged', (accounts) => {
                        if (accounts.length > 0) {
                            this.logToTerminal(`üîÑ Account changed to: ${this.shortAddress(accounts[0])}`);
                            location.reload(); // Reload to reset state
                        } else {
                            this.logToTerminal('üë§ Account disconnected');
                            location.reload();
                        }
                    });
                    
                    // Listen for network changes
                    window.ethereum.on('chainChanged', (chainId) => {
                        this.logToTerminal(`üåê Network changed to: ${chainId}`);
                        location.reload(); // Reload to ensure correct network state
                    });
                    
                } else {
                    this.logToTerminal('‚ùå MetaMask not detected!');
                    this.logToTerminal('üí° Please install MetaMask to play with blockchain features');
                }
            }

            setupEventListeners() {
                document.getElementById('connectWalletBtn').addEventListener('click', () => this.connectWallet());
                document.getElementById('connectMultisynqBtn').addEventListener('click', () => this.connectMultisynq());
                document.getElementById('joinGameBtn').addEventListener('click', () => this.joinGame());
                document.getElementById('startGameBtn').addEventListener('click', () => this.startGame());
                document.getElementById('rollDiceBtn').addEventListener('click', () => this.rollDice());
                
                // Blockchain mode toggle
                document.getElementById('blockchainModeToggle').addEventListener('change', (e) => {
                    if (e.target.checked) {
                        this.logToTerminal('‚õìÔ∏è Blockchain mode enabled - rolls cost MON + gas');
                    } else {
                        this.logToTerminal('üÜì Local mode enabled - free dice rolls');
                    }
                });
                
                // Room code functionality
                document.getElementById('createRoomBtn').addEventListener('click', () => this.createRoom());
                document.getElementById('joinRoomBtn').addEventListener('click', () => this.joinRoom());
                document.getElementById('roomCodeInput').addEventListener('input', (e) => {
                    e.target.value = e.target.value.toUpperCase().replace(/[^A-Z0-9]/g, '');
                });
                document.getElementById('roomCodeInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.joinRoom();
                });
            }

            startConnectionSequence() {
                setTimeout(() => {
                    this.logToTerminal('üîÑ Starting connection sequence...');
                    // Only auto-connect to Multisynq, don't force demo mode with room codes
                    this.connectMultisynq();
                }, 1500);
            }

            // üéµ AUDIO SYSTEM
            async initAudioSystem() {
                try {
                    // Initialize Web Audio API
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.logToTerminal('üéµ Audio system initialized');
                    
                    // Generate procedural sounds
                    this.createProceduralSounds();
                    
                    // Start background music
                    this.startBackgroundMusic();
                    
                } catch (error) {
                    console.error('Audio system failed:', error);
                    this.logToTerminal('‚ö†Ô∏è Audio system unavailable (browser limitation)');
                }
            }

            // ÔøΩ ENHANCED MULTIPLAYER SYSTEM
            initEnhancedMultiplayer() {
                try {
                    this.logToTerminal('üéÆ Initializing enhanced multiplayer...');
                    this.lobbyPlayers = [];
                    this.isReady = false;
                    this.isHost = false;
                    this.diceHistory = [];
                    this.currentTurn = 0;
                    this.turnTimer = null;
                    
                    this.setupMultiplayerEventListeners();
                    this.logToTerminal('üéÆ Enhanced multiplayer system initialized');
                } catch (error) {
                    this.logToTerminal(`‚ùå Error in enhanced multiplayer: ${error.message}`);
                    console.error('Enhanced multiplayer error:', error);
                }
            }

            setupMultiplayerEventListeners() {
                // Connect wallet button
                const connectBtn = document.getElementById('connectWalletBtn');
                if (connectBtn) {
                    connectBtn.addEventListener('click', () => {
                        this.connectWallet();
                    });
                }

                // Create room button
                const createBtn = document.getElementById('createRoom');
                if (createBtn) {
                    createBtn.addEventListener('click', () => {
                        this.createGameRoom();
                    });
                }

                // Join room functionality
                const joinBtn = document.getElementById('joinRoomBtn');
                if (joinBtn) {
                    joinBtn.addEventListener('click', () => {
                        const roomCodeInput = document.getElementById('roomCodeInput');
                        if (roomCodeInput) {
                            const roomCode = roomCodeInput.value.trim();
                            if (roomCode.length === 6) {
                                this.joinGameRoom(roomCode);
                            } else {
                                this.logToTerminal('‚ö†Ô∏è Please enter a valid 6-digit room code');
                            }
                        }
                    });
                }

                // Ready toggle
                const readyBtn = document.getElementById('readyToggle');
                if (readyBtn) {
                    readyBtn.addEventListener('click', () => {
                        this.toggleReady();
                    });
                }

                // Spectate button
                const spectateBtn = document.getElementById('spectateBtn');
                if (spectateBtn) {
                    spectateBtn.addEventListener('click', () => {
                        this.spectateGame();
                    });
                }

                // Room code input formatting
                const roomCodeInput = document.getElementById('roomCodeInput');
                if (roomCodeInput) {
                    roomCodeInput.addEventListener('input', (e) => {
                        e.target.value = e.target.value.toUpperCase().replace(/[^A-Z0-9]/g, '');
                    });
                }
            }

            async createGameRoom() {
                try {
                    this.logToTerminal('ÔøΩ Creating game room...');
                    
                    // Generate room code
                    this.roomCode = this.generateRoomCode();
                    this.isHost = true;
                    
                    // Update UI
                    this.showRoomInfo();
                    this.addPlayerToLobby(this.currentPlayer, true);
                    this.updateGameStatus('Room Created', 'ready');
                    
                    this.logToTerminal(`üè† Room created! Code: ${this.roomCode}`);
                    this.logToTerminal('üì§ Share this code with friends to join');
                    
                } catch (error) {
                    this.logToTerminal(`‚ùå Failed to create room: ${error.message}`);
                }
            }

            async joinGameRoom(roomCode) {
                try {
                    this.logToTerminal(`üö™ Joining room ${roomCode}...`);
                    
                    // Simulate room validation
                    if (this.validateRoomCode(roomCode)) {
                        this.roomCode = roomCode;
                        this.isHost = false;
                        
                        this.showRoomInfo();
                        this.addPlayerToLobby(this.currentPlayer, false);
                        this.updateGameStatus('Joined Room', 'ready');
                        
                        this.logToTerminal(`‚úÖ Successfully joined room ${roomCode}`);
                        
                        // Show ready system
                        document.getElementById('readySystem').style.display = 'block';
                        
                    } else {
                        throw new Error('Room not found or full');
                    }
                    
                } catch (error) {
                    this.logToTerminal(`‚ùå Failed to join room: ${error.message}`);
                }
            }

            generateRoomCode() {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                let result = '';
                for (let i = 0; i < 6; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result;
            }

            validateRoomCode(code) {
                // Simulate room validation - in real implementation, this would check with server
                return code.length === 6 && /^[A-Z0-9]{6}$/.test(code);
            }

            showRoomInfo() {
                document.getElementById('roomInfo').style.display = 'block';
                document.getElementById('roomCodeDisplay').textContent = this.roomCode;
                document.getElementById('joinRoomSection').style.display = this.isHost ? 'none' : 'block';
                
                if (this.isHost) {
                    document.getElementById('readySystem').style.display = 'none';
                    document.getElementById('startGameBtn').disabled = false;
                } else {
                    document.getElementById('readySystem').style.display = 'block';
                }
                
                this.updatePlayerCount();
            }

            addPlayerToLobby(player, isHost = false) {
                const lobbyPlayer = {
                    address: player.address,
                    avatar: player.avatar,
                    name: this.shortenAddress(player.address),
                    isHost: isHost,
                    isReady: isHost, // Host is always ready
                    isYou: player.isYou
                };
                
                this.lobbyPlayers.push(lobbyPlayer);
                this.renderLobbyPlayers();
                this.updatePlayerCount();
            }

            renderLobbyPlayers() {
                const container = document.getElementById('lobbyPlayers');
                container.innerHTML = '';
                
                this.lobbyPlayers.forEach((player, index) => {
                    const playerElement = document.createElement('div');
                    playerElement.className = `lobby-player ${player.isReady ? 'ready' : ''} ${player.isHost ? 'host' : ''}`;
                    
                    playerElement.innerHTML = `
                        <div class="player-info">
                            <div class="player-avatar">${player.avatar}</div>
                            <div>
                                <div class="player-name">${player.isYou ? 'You' : `Player ${index + 1}`}</div>
                                <div class="player-address">${player.name}</div>
                            </div>
                        </div>
                        <div class="player-status">
                            <span class="status-badge ${player.isHost ? 'host' : player.isReady ? 'ready' : 'waiting'}">
                                ${player.isHost ? 'üëë Host' : player.isReady ? '‚úÖ Ready' : '‚è≥ Waiting'}
                            </span>
                        </div>
                    `;
                    
                    container.appendChild(playerElement);
                });
            }

            updatePlayerCount() {
                document.getElementById('playerCount').textContent = this.lobbyPlayers.length;
                
                const readyCount = this.lobbyPlayers.filter(p => p.isReady).length;
                document.getElementById('readyCount').textContent = readyCount;
                
                // Update room status
                const statusElement = document.getElementById('roomStatus');
                if (this.lobbyPlayers.length < 2) {
                    statusElement.textContent = 'Waiting for players';
                    statusElement.className = 'status-waiting';
                } else if (readyCount === this.lobbyPlayers.length && this.lobbyPlayers.length >= 2) {
                    statusElement.textContent = 'All players ready';
                    statusElement.className = 'status-ready';
                } else {
                    statusElement.textContent = 'Players joining';
                    statusElement.className = 'status-waiting';
                }
            }

            toggleReady() {
                this.isReady = !this.isReady;
                
                // Update local player in lobby
                const localPlayer = this.lobbyPlayers.find(p => p.isYou);
                if (localPlayer) {
                    localPlayer.isReady = this.isReady;
                }
                
                // Update UI
                const readyBtn = document.getElementById('readyToggle');
                if (this.isReady) {
                    readyBtn.textContent = '‚úÖ READY';
                    readyBtn.className = 'btn secondary ready-btn active';
                    this.logToTerminal('‚úÖ You are ready to start!');
                } else {
                    readyBtn.textContent = '‚úã READY UP';
                    readyBtn.className = 'btn secondary ready-btn';
                    this.logToTerminal('‚è≥ You are not ready');
                }
                
                this.renderLobbyPlayers();
                this.updatePlayerCount();
            }

            updateGameStatus(status, type = 'waiting') {
                document.getElementById('statusText').textContent = status;
                const dot = document.querySelector('.status-dot');
                dot.className = `status-dot ${type}`;
            }

            // üé≤ Dice History System
            addDiceRoll(player, roll, position) {
                const rollData = {
                    player: player,
                    roll: roll,
                    position: position,
                    time: new Date().toLocaleTimeString()
                };
                
                this.diceHistory.unshift(rollData);
                if (this.diceHistory.length > 10) {
                    this.diceHistory.pop(); // Keep only last 10 rolls
                }
                
                this.renderDiceHistory();
            }

            renderDiceHistory() {
                const container = document.getElementById('diceHistory');
                
                if (this.diceHistory.length === 0) {
                    container.innerHTML = '<div class="history-placeholder">No rolls yet</div>';
                    return;
                }
                
                container.innerHTML = '';
                this.diceHistory.forEach(roll => {
                    const historyItem = document.createElement('div');
                    historyItem.className = 'history-item';
                    
                    historyItem.innerHTML = `
                        <div class="history-player">
                            <span class="player-avatar">${roll.player.avatar}</span>
                            <span>${roll.player.isYou ? 'You' : 'Player'}</span>
                        </div>
                        <div class="history-roll">üé≤ ${roll.roll}</div>
                        <div class="history-time">${roll.time}</div>
                    `;
                    
                    container.appendChild(historyItem);
                });
            }

            // ‚è∞ Turn Timer System
            startTurnTimer(duration = 30) {
                this.clearTurnTimer();
                
                const timerBar = document.querySelector('.timer-bar');
                timerBar.style.width = '100%';
                
                let timeLeft = duration;
                this.turnTimer = setInterval(() => {
                    timeLeft--;
                    const percentage = (timeLeft / duration) * 100;
                    timerBar.style.width = `${percentage}%`;
                    
                    if (timeLeft <= 0) {
                        this.clearTurnTimer();
                        this.handleTurnTimeout();
                    }
                }, 1000);
            }

            clearTurnTimer() {
                if (this.turnTimer) {
                    clearInterval(this.turnTimer);
                    this.turnTimer = null;
                }
            }

            handleTurnTimeout() {
                this.logToTerminal('‚è∞ Turn timer expired - skipping turn');
                // Auto-roll or skip turn logic here
            }

            showTurnIndicator(playerName, isYourTurn = false) {
                const indicator = document.getElementById('turnIndicator');
                const playerDisplay = document.getElementById('currentTurnPlayer');
                
                indicator.style.display = 'block';
                playerDisplay.textContent = isYourTurn ? 'Your Turn!' : `${playerName}'s Turn`;
                
                if (isYourTurn) {
                    indicator.style.borderColor = 'var(--accent-green)';
                    this.startTurnTimer();
                } else {
                    indicator.style.borderColor = 'var(--accent-blue)';
                    this.clearTurnTimer();
                }
            }

            // üì± MOBILE OPTIMIZATION SYSTEM
            initMobileOptimization() {
                this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                this.isTouch = 'ontouchstart' in window;
                
                if (this.isMobile || this.isTouch) {
                    this.setupTouchControls();
                    this.setupHapticFeedback();
                    this.optimizeForMobile();
                    this.logToTerminal('üì± Mobile optimizations enabled');
                } else {
                    this.logToTerminal('üñ•Ô∏è Desktop mode active');
                }
            }

            setupTouchControls() {
                // Add swipe gestures for board navigation
                let startX = 0;
                let startY = 0;
                
                const boardArea = document.querySelector('.board-area');
                if (boardArea) {
                    boardArea.classList.add('swipe-area');
                    
                    boardArea.addEventListener('touchstart', (e) => {
                        startX = e.touches[0].clientX;
                        startY = e.touches[0].clientY;
                    }, { passive: true });
                    
                    boardArea.addEventListener('touchmove', (e) => {
                        if (!startX || !startY) return;
                        
                        const diffX = startX - e.touches[0].clientX;
                        const diffY = startY - e.touches[0].clientY;
                        
                        // Prevent default scrolling if gesture is intended for board navigation
                        if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 50) {
                            e.preventDefault();
                        }
                    }, { passive: false });
                    
                    boardArea.addEventListener('touchend', (e) => {
                        if (!startX || !startY) return;
                        
                        const diffX = startX - e.changedTouches[0].clientX;
                        const diffY = startY - e.changedTouches[0].clientY;
                        
                        // Handle swipe gestures
                        if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 100) {
                            if (diffX > 0) {
                                this.handleSwipeLeft();
                            } else {
                                this.handleSwipeRight();
                            }
                        }
                        
                        startX = 0;
                        startY = 0;
                    }, { passive: true });
                }
                
                // Add double-tap to zoom on board
                let lastTap = 0;
                boardArea.addEventListener('touchend', (e) => {
                    const currentTime = new Date().getTime();
                    const tapLength = currentTime - lastTap;
                    
                    if (tapLength < 500 && tapLength > 0) {
                        // Double tap detected
                        this.handleBoardDoubleTap(e);
                        e.preventDefault();
                    }
                    lastTap = currentTime;
                });
            }

            setupHapticFeedback() {
                // Check if device supports haptic feedback
                this.hasHaptics = 'vibrate' in navigator;
                
                if (this.hasHaptics) {
                    // Add haptic feedback to important actions
                    const addHapticToButton = (buttonId, pattern = [50]) => {
                        const button = document.getElementById(buttonId);
                        if (button) {
                            button.addEventListener('click', () => {
                                navigator.vibrate(pattern);
                            });
                        }
                    };
                    
                    // Add haptics to key buttons
                    addHapticToButton('rollDiceBtn', [100, 50, 100]); // Double pulse for dice
                    addHapticToButton('startGameBtn', [200]); // Long pulse for start
                    addHapticToButton('connectWallet', [50]); // Short pulse for connect
                    addHapticToButton('readyToggle', [75]); // Medium pulse for ready
                    
                    this.logToTerminal('üì≥ Haptic feedback enabled');
                }
            }

            optimizeForMobile() {
                // Adjust viewport for better mobile experience
                const viewport = document.querySelector('meta[name="viewport"]');
                if (viewport) {
                    viewport.setAttribute('content', 
                        'width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0'
                    );
                }
                
                // Add mobile-specific CSS class
                document.body.classList.add('mobile-optimized');
                
                // Prevent zoom on input focus (iOS fix)
                const inputs = document.querySelectorAll('input[type="text"], input[type="number"]');
                inputs.forEach(input => {
                    input.addEventListener('focus', () => {
                        input.style.fontSize = '16px';
                    });
                });
                
                // Optimize modal behavior for mobile
                const modals = document.querySelectorAll('.modal-overlay');
                modals.forEach(modal => {
                    // Close modal when tapping backdrop on mobile
                    modal.addEventListener('touchend', (e) => {
                        if (e.target === modal) {
                            modal.remove();
                        }
                    });
                });
                
                // Add orientation change handling
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => {
                        this.handleOrientationChange();
                    }, 300);
                });
            }

            handleSwipeLeft() {
                // Navigate to next section or close sidebar
                this.logToTerminal('üëà Swipe left detected');
                if (this.isSidebarOpen) {
                    this.closeSidebar();
                }
            }

            handleSwipeRight() {
                // Navigate to previous section or open sidebar
                this.logToTerminal('üëâ Swipe right detected');
                if (!this.isSidebarOpen) {
                    this.openSidebar();
                }
            }

            handleBoardDoubleTap(e) {
                // Zoom in/out on board
                const board = document.querySelector('.game-board');
                if (board) {
                    const isZoomed = board.classList.contains('zoomed');
                    
                    if (isZoomed) {
                        board.classList.remove('zoomed');
                        board.style.transform = 'scale(1)';
                        this.logToTerminal('üîç Board zoom: Normal');
                    } else {
                        board.classList.add('zoomed');
                        board.style.transform = 'scale(1.5)';
                        board.style.transformOrigin = `${e.changedTouches[0].clientX}px ${e.changedTouches[0].clientY}px`;
                        this.logToTerminal('üîç Board zoom: Enhanced');
                    }
                    
                    // Haptic feedback for zoom
                    if (this.hasHaptics) {
                        navigator.vibrate([30, 30, 30]);
                    }
                }
            }

            handleOrientationChange() {
                // Adjust layout for orientation change
                const orientation = window.innerHeight > window.innerWidth ? 'portrait' : 'landscape';
                document.body.setAttribute('data-orientation', orientation);
                
                this.logToTerminal(`üì± Orientation: ${orientation}`);
                
                // Refresh board layout
                setTimeout(() => {
                    this.createModernBoard();
                    this.addSnakesAndLadders();
                    this.updateAllUI();
                }, 100);
            }

            // Mobile-specific UI helpers
            closeSidebar() {
                const sidebar = document.querySelector('.sidebar');
                if (sidebar) {
                    sidebar.style.transform = 'translateX(-100%)';
                    this.isSidebarOpen = false;
                }
            }

            openSidebar() {
                const sidebar = document.querySelector('.sidebar');
                if (sidebar) {
                    sidebar.style.transform = 'translateX(0)';
                    this.isSidebarOpen = true;
                }
            }

            // Enhanced dice roll with haptic feedback
            async rollDiceWithHaptics() {
                // Haptic feedback pattern for dice roll
                if (this.hasHaptics) {
                    // Rolling pattern: quick pulses
                    navigator.vibrate([50, 30, 50, 30, 50]);
                    
                    // Wait for roll result, then give result feedback
                    setTimeout(() => {
                        if (this.lastDiceRoll) {
                            if (this.lastDiceRoll >= 5) {
                                navigator.vibrate([100, 50, 100]); // Good roll
                            } else {
                                navigator.vibrate([200]); // Regular roll
                            }
                        }
                    }, 2000);
                }
            }

            // Touch-optimized notifications
            showMobileNotification(message, type = 'info', duration = 3000) {
                const notification = document.createElement('div');
                notification.className = `mobile-notification ${type}`;
                notification.textContent = message;
                
                // Position at top of screen for mobile
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: var(--bg-secondary);
                    color: var(--text-primary);
                    padding: 1rem 2rem;
                    border-radius: 25px;
                    border: 2px solid var(--accent-blue);
                    z-index: 10000;
                    font-size: 1rem;
                    font-weight: 600;
                    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
                    animation: slideInFromTop 0.3s ease-out;
                `;
                
                document.body.appendChild(notification);
                
                // Auto-remove after duration
                setTimeout(() => {
                    notification.style.animation = 'slideOutToTop 0.3s ease-in';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }, duration);
                
                // Haptic feedback for notification
                if (this.hasHaptics && type === 'success') {
                    navigator.vibrate([50, 30, 50]);
                }
            }

            // üé™ ADVANCED ANIMATIONS SYSTEM
            initAdvancedAnimations() {
                this.animationQueue = [];
                this.isAnimating = false;
                this.particleCount = 0;
                this.maxParticles = 50;
                
                this.setupPlayerTrails();
                this.setupAnimatedBoardElements();
                this.setupWeatherEffects();
                this.setupEmoteSystem();
                
                this.logToTerminal('üé™ Advanced animations initialized');
            }

            setupPlayerTrails() {
                // Create trail containers for each player
                this.playerTrails = {};
                this.players.forEach((player, index) => {
                    this.playerTrails[player.address] = {
                        trail: [],
                        maxLength: 10,
                        color: this.getPlayerColor(index)
                    };
                });
            }

            addPlayerTrail(player, fromPosition, toPosition) {
                if (!this.playerTrails[player.address]) return;
                
                const trail = this.playerTrails[player.address];
                trail.trail.push({
                    from: fromPosition,
                    to: toPosition,
                    timestamp: Date.now(),
                    opacity: 1
                });
                
                // Keep trail length manageable
                if (trail.trail.length > trail.maxLength) {
                    trail.trail.shift();
                }
                
                this.renderPlayerTrails();
            }

            renderPlayerTrails() {
                // Remove old trail elements
                document.querySelectorAll('.player-trail').forEach(el => el.remove());
                
                Object.values(this.playerTrails).forEach(trailData => {
                    trailData.trail.forEach((segment, index) => {
                        const age = Date.now() - segment.timestamp;
                        const opacity = Math.max(0, 1 - (age / 5000)); // Fade over 5 seconds
                        
                        if (opacity > 0) {
                            this.createTrailSegment(segment, trailData.color, opacity, index);
                        }
                    });
                });
                
                // Clean up old trail segments
                Object.values(this.playerTrails).forEach(trailData => {
                    trailData.trail = trailData.trail.filter(segment => {
                        const age = Date.now() - segment.timestamp;
                        return age < 5000;
                    });
                });
            }

            createTrailSegment(segment, color, opacity, index) {
                const fromCell = document.querySelector(`[data-position="${segment.from}"]`);
                const toCell = document.querySelector(`[data-position="${segment.to}"]`);
                
                if (!fromCell || !toCell) return;
                
                const fromRect = fromCell.getBoundingClientRect();
                const toRect = toCell.getBoundingClientRect();
                const boardRect = document.querySelector('.game-board').getBoundingClientRect();
                
                const trail = document.createElement('div');
                trail.className = 'player-trail';
                trail.style.cssText = `
                    position: absolute;
                    width: 3px;
                    height: ${Math.sqrt(Math.pow(toRect.left - fromRect.left, 2) + Math.pow(toRect.top - fromRect.top, 2))}px;
                    background: linear-gradient(0deg, transparent, ${color});
                    transform-origin: top;
                    transform: rotate(${Math.atan2(toRect.top - fromRect.top, toRect.left - fromRect.left) * 180 / Math.PI + 90}deg);
                    left: ${fromRect.left - boardRect.left + fromRect.width / 2}px;
                    top: ${fromRect.top - boardRect.top + fromRect.height / 2}px;
                    opacity: ${opacity};
                    pointer-events: none;
                    z-index: 1;
                    animation: trailPulse 2s ease-in-out infinite;
                `;
                
                document.querySelector('.game-board').appendChild(trail);
            }

            setupAnimatedBoardElements() {
                // Add animated snakes and ladders
                this.animateSnakes();
                this.animateLadders();
                this.addBoardEffects();
            }

            animateSnakes() {
                const snakes = [
                    { start: 17, end: 7 },
                    { start: 54, end: 34 },
                    { start: 98, end: 79 }
                ];
                
                snakes.forEach((snake, index) => {
                    const startCell = document.querySelector(`[data-position="${snake.start}"]`);
                    const endCell = document.querySelector(`[data-position="${snake.end}"]`);
                    
                    if (startCell && endCell) {
                        // Add slithering animation to snake path
                        const snakeElement = document.createElement('div');
                        snakeElement.className = 'animated-snake';
                        snakeElement.innerHTML = 'üêç';
                        snakeElement.style.cssText = `
                            position: absolute;
                            font-size: 2rem;
                            z-index: 3;
                            animation: snakeSlither 4s ease-in-out infinite;
                            filter: drop-shadow(0 0 10px rgba(239, 68, 68, 0.6));
                        `;
                        
                        // Position between start and end
                        this.positionSnakeBetween(snakeElement, startCell, endCell);
                        document.querySelector('.game-board').appendChild(snakeElement);
                    }
                });
            }

            animateLadders() {
                const ladders = [
                    { start: 4, end: 14 },
                    { start: 9, end: 31 },
                    { start: 20, end: 38 }
                ];
                
                ladders.forEach((ladder, index) => {
                    const startCell = document.querySelector(`[data-position="${ladder.start}"]`);
                    const endCell = document.querySelector(`[data-position="${ladder.end}"]`);
                    
                    if (startCell && endCell) {
                        // Add climbing sparkle animation
                        const ladderElement = document.createElement('div');
                        ladderElement.className = 'animated-ladder';
                        ladderElement.innerHTML = 'ü™ú‚ú®';
                        ladderElement.style.cssText = `
                            position: absolute;
                            font-size: 1.8rem;
                            z-index: 3;
                            animation: ladderSparkle 3s ease-in-out infinite;
                            filter: drop-shadow(0 0 10px rgba(16, 185, 129, 0.6));
                        `;
                        
                        this.positionLadderBetween(ladderElement, startCell, endCell);
                        document.querySelector('.game-board').appendChild(ladderElement);
                    }
                });
            }

            positionSnakeBetween(element, startCell, endCell) {
                const startRect = startCell.getBoundingClientRect();
                const endRect = endCell.getBoundingClientRect();
                const boardRect = document.querySelector('.game-board').getBoundingClientRect();
                
                const midX = (startRect.left + endRect.left) / 2 - boardRect.left;
                const midY = (startRect.top + endRect.top) / 2 - boardRect.top;
                
                element.style.left = `${midX}px`;
                element.style.top = `${midY}px`;
                element.style.transform = 'translate(-50%, -50%)';
            }

            positionLadderBetween(element, startCell, endCell) {
                const startRect = startCell.getBoundingClientRect();
                const endRect = endCell.getBoundingClientRect();
                const boardRect = document.querySelector('.game-board').getBoundingClientRect();
                
                const midX = (startRect.left + endRect.left) / 2 - boardRect.left;
                const midY = (startRect.top + endRect.top) / 2 - boardRect.top;
                
                element.style.left = `${midX}px`;
                element.style.top = `${midY}px`;
                element.style.transform = 'translate(-50%, -50%)';
            }

            addBoardEffects() {
                // Add floating particles around the board
                this.createFloatingParticles();
                
                // Add pulsing border effect
                const board = document.querySelector('.game-board');
                if (board) {
                    board.style.animation = 'boardPulse 8s ease-in-out infinite';
                }
            }

            createFloatingParticles() {
                const particleContainer = document.createElement('div');
                particleContainer.className = 'floating-particles';
                particleContainer.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 1;
                `;
                
                // Create 15 floating particles
                for (let i = 0; i < 15; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'floating-particle';
                    particle.innerHTML = ['‚ú®', 'üí´', '‚≠ê', 'üåü'][Math.floor(Math.random() * 4)];
                    particle.style.cssText = `
                        position: absolute;
                        font-size: ${Math.random() * 1 + 0.5}rem;
                        left: ${Math.random() * 100}%;
                        top: ${Math.random() * 100}%;
                        opacity: ${Math.random() * 0.5 + 0.2};
                        animation: floatRandom ${Math.random() * 10 + 5}s ease-in-out infinite;
                        animation-delay: ${Math.random() * 5}s;
                    `;
                    
                    particleContainer.appendChild(particle);
                }
                
                document.querySelector('.game-board').appendChild(particleContainer);
            }

            setupWeatherEffects() {
                this.currentWeather = 'clear';
                this.weatherContainer = document.createElement('div');
                this.weatherContainer.className = 'weather-effects';
                this.weatherContainer.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 2;
                `;
                
                document.querySelector('.game-board').appendChild(this.weatherContainer);
            }

            changeWeather(weather) {
                this.currentWeather = weather;
                this.weatherContainer.innerHTML = '';
                
                switch (weather) {
                    case 'rain':
                        this.createRainEffect();
                        break;
                    case 'snow':
                        this.createSnowEffect();
                        break;
                    case 'stars':
                        this.createStarEffect();
                        break;
                    default:
                        // Clear weather
                        break;
                }
                
                this.logToTerminal(`üå§Ô∏è Weather changed to: ${weather}`);
            }

            createRainEffect() {
                for (let i = 0; i < 30; i++) {
                    const drop = document.createElement('div');
                    drop.className = 'rain-drop';
                    drop.style.cssText = `
                        position: absolute;
                        width: 2px;
                        height: 20px;
                        background: linear-gradient(transparent, rgba(6, 182, 212, 0.6), transparent);
                        left: ${Math.random() * 100}%;
                        animation: rainFall ${Math.random() * 1 + 0.5}s linear infinite;
                        animation-delay: ${Math.random() * 2}s;
                    `;
                    
                    this.weatherContainer.appendChild(drop);
                }
            }

            createSnowEffect() {
                for (let i = 0; i < 25; i++) {
                    const flake = document.createElement('div');
                    flake.className = 'snow-flake';
                    flake.innerHTML = '‚ùÑÔ∏è';
                    flake.style.cssText = `
                        position: absolute;
                        font-size: ${Math.random() * 1 + 0.5}rem;
                        left: ${Math.random() * 100}%;
                        opacity: ${Math.random() * 0.8 + 0.2};
                        animation: snowFall ${Math.random() * 3 + 2}s linear infinite;
                        animation-delay: ${Math.random() * 5}s;
                    `;
                    
                    this.weatherContainer.appendChild(flake);
                }
            }

            createStarEffect() {
                for (let i = 0; i < 20; i++) {
                    const star = document.createElement('div');
                    star.className = 'star-twinkle';
                    star.innerHTML = '‚≠ê';
                    star.style.cssText = `
                        position: absolute;
                        font-size: ${Math.random() * 1 + 0.5}rem;
                        left: ${Math.random() * 100}%;
                        top: ${Math.random() * 100}%;
                        animation: starTwinkle ${Math.random() * 2 + 1}s ease-in-out infinite;
                        animation-delay: ${Math.random() * 3}s;
                    `;
                    
                    this.weatherContainer.appendChild(star);
                }
            }

            setupEmoteSystem() {
                this.availableEmotes = ['üòÑ', 'üò¢', 'üéâ', 'üí™', 'üòÆ', 'ü§î', 'üî•', '‚ö°'];
                this.emoteQueue = [];
                
                // Add emote buttons (could be shown in a modal)
                this.createEmoteInterface();
            }

            createEmoteInterface() {
                // This would be shown in a quick-access panel or modal
                this.emotePanel = document.createElement('div');
                this.emotePanel.className = 'emote-panel';
                this.emotePanel.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    background: var(--bg-secondary);
                    border: 2px solid var(--border-color);
                    border-radius: 15px;
                    padding: 1rem;
                    display: none;
                    z-index: 1000;
                    gap: 0.5rem;
                    flex-wrap: wrap;
                    max-width: 200px;
                `;
                
                this.availableEmotes.forEach(emote => {
                    const emoteBtn = document.createElement('button');
                    emoteBtn.textContent = emote;
                    emoteBtn.className = 'emote-btn';
                    emoteBtn.style.cssText = `
                        background: none;
                        border: 2px solid var(--border-color);
                        border-radius: 10px;
                        padding: 0.5rem;
                        font-size: 1.5rem;
                        cursor: pointer;
                        transition: all 0.3s ease;
                    `;
                    
                    emoteBtn.addEventListener('click', () => {
                        this.sendEmote(emote);
                    });
                    
                    this.emotePanel.appendChild(emoteBtn);
                });
                
                document.body.appendChild(this.emotePanel);
            }

            sendEmote(emote) {
                const player = this.players.find(p => p.isYou);
                if (player) {
                    this.showEmoteOnBoard(player, emote);
                    this.logToTerminal(`${emote} You sent an emote!`);
                    
                    // Hide emote panel
                    this.emotePanel.style.display = 'none';
                }
            }

            showEmoteOnBoard(player, emote) {
                const playerCell = document.querySelector(`[data-position="${player.position}"]`);
                if (!playerCell) return;
                
                const emoteElement = document.createElement('div');
                emoteElement.className = 'board-emote';
                emoteElement.textContent = emote;
                emoteElement.style.cssText = `
                    position: absolute;
                    font-size: 2rem;
                    z-index: 10;
                    animation: emoteFloat 2s ease-out forwards;
                    pointer-events: none;
                `;
                
                const rect = playerCell.getBoundingClientRect();
                const boardRect = document.querySelector('.game-board').getBoundingClientRect();
                
                emoteElement.style.left = `${rect.left - boardRect.left + rect.width / 2}px`;
                emoteElement.style.top = `${rect.top - boardRect.top}px`;
                emoteElement.style.transform = 'translate(-50%, -100%)';
                
                document.querySelector('.game-board').appendChild(emoteElement);
                
                // Remove after animation
                setTimeout(() => {
                    if (emoteElement.parentNode) {
                        emoteElement.parentNode.removeChild(emoteElement);
                    }
                }, 2000);
            }

            toggleEmotePanel() {
                const isVisible = this.emotePanel.style.display !== 'none';
                this.emotePanel.style.display = isVisible ? 'none' : 'flex';
            }

            // üåü MODAL SYSTEM
            initModalSystem() {
                this.logToTerminal('üåü Modal system initialized');
                
                // Check if buttons exist before setting up listeners
                const audioBtn = document.getElementById('audioControlBtn');
                const customBtn = document.getElementById('customizationBtn');
                const statsBtn = document.getElementById('statisticsBtn');
                const settingsBtn = document.getElementById('settingsBtn');
                
                this.logToTerminal(`üîç Buttons found - Audio: ${!!audioBtn}, Custom: ${!!customBtn}, Stats: ${!!statsBtn}, Settings: ${!!settingsBtn}`);
                
                this.createModalEventListeners();
                this.loadPlayerStats();
                this.selectedAvatar = this.playerAvatars[0]; // Default avatar
            }

            createModalEventListeners() {
                // Use setTimeout to ensure DOM is ready
                setTimeout(() => {
                    this.logToTerminal('üîÑ Setting up modal event listeners...');
                    
                // Add global test function for debugging
                window.testModal = () => {
                    this.logToTerminal('üß™ Testing modal function directly...');
                    this.showAudioModal();
                };
                    // Audio Control Modal
                    const audioBtn = document.getElementById('audioControlBtn');
                    if (audioBtn) {
                        this.logToTerminal('üéµ Found audio button, attaching listener...');
                        audioBtn.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            this.logToTerminal('üéµ Audio button clicked!');
                            try {
                                this.showAudioModal();
                                this.logToTerminal('‚úÖ Audio modal function called successfully');
                            } catch (error) {
                                this.logToTerminal('‚ùå Error calling audio modal: ' + error.message);
                                console.error('Modal error:', error);
                            }
                        });
                        this.logToTerminal('‚úÖ Audio button listener attached');
                    } else {
                        this.logToTerminal('‚ùå Audio button not found');
                    }

                    // Customization Modal  
                    const customBtn = document.getElementById('customizationBtn');
                    if (customBtn) {
                        this.logToTerminal('üé® Found customization button, attaching listener...');
                        customBtn.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            this.logToTerminal('üé® Customization button clicked!');
                            try {
                                this.showCustomizationModal();
                                this.logToTerminal('‚úÖ Customization modal function called successfully');
                            } catch (error) {
                                this.logToTerminal('‚ùå Error calling customization modal: ' + error.message);
                                console.error('Modal error:', error);
                            }
                        });
                        this.logToTerminal('‚úÖ Customization button listener attached');
                    } else {
                        this.logToTerminal('‚ùå Customization button not found');
                    }

                    // Statistics Modal
                    const statsBtn = document.getElementById('statisticsBtn');
                    if (statsBtn) {
                        this.logToTerminal('üèÜ Found statistics button, attaching listener...');
                        statsBtn.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            this.logToTerminal('üèÜ Statistics button clicked!');
                            try {
                                this.showStatisticsModal();
                                this.logToTerminal('‚úÖ Statistics modal function called successfully');
                            } catch (error) {
                                this.logToTerminal('‚ùå Error calling statistics modal: ' + error.message);
                                console.error('Modal error:', error);
                            }
                        });
                        this.logToTerminal('‚úÖ Statistics button listener attached');
                    } else {
                        this.logToTerminal('‚ùå Statistics button not found');
                    }

                    // Settings Modal
                    const settingsBtn = document.getElementById('settingsBtn');
                    if (settingsBtn) {
                        this.logToTerminal('‚öôÔ∏è Found settings button, attaching listener...');
                        settingsBtn.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            this.logToTerminal('‚öôÔ∏è Settings button clicked!');
                            try {
                                this.showSettingsModal();
                                this.logToTerminal('‚úÖ Settings modal function called successfully');
                            } catch (error) {
                                this.logToTerminal('‚ùå Error calling settings modal: ' + error.message);
                                console.error('Modal error:', error);
                            }
                        });
                        this.logToTerminal('‚úÖ Settings button listener attached');
                    } else {
                        this.logToTerminal('‚ùå Settings button not found');
                    }
                    
                    this.logToTerminal('ÔøΩ All modal event listeners setup complete!');
                    
                    // Test button detection
                    const allButtons = document.querySelectorAll('.header-btn');
                    this.logToTerminal(`üîç Found ${allButtons.length} header buttons total`);
                    allButtons.forEach((btn, index) => {
                        this.logToTerminal(`  Button ${index + 1}: ${btn.id} - "${btn.textContent.trim()}"`);
                    });
                    
                }, 2000); // Increased timeout to 2 seconds
            }

            showAudioModal() {
                this.logToTerminal('üéµ Opening audio modal...');
                const modalHTML = `
                    <div class="modal-overlay" id="audioModal">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h3 class="modal-title">üéµ Audio Controls</h3>
                                <button class="modal-close" onclick="document.getElementById('audioModal').remove()">√ó</button>
                            </div>
                            
                            <div class="modal-section">
                                <h4>üéº Music & Sound</h4>
                                
                                <div class="control-group">
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="musicToggleModal" ${this.musicEnabled ? 'checked' : ''}>
                                        <span>üéº Background Music</span>
                                    </label>
                                </div>
                                
                                <div class="control-group">
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="soundToggleModal" ${this.soundEnabled ? 'checked' : ''}>
                                        <span>üîä Sound Effects</span>
                                    </label>
                                </div>
                                
                                <div class="control-group">
                                    <label class="control-label">üéöÔ∏è Master Volume</label>
                                    <input type="range" id="volumeSliderModal" class="control-input" min="0" max="100" value="${this.masterVolume * 100}">
                                    <div style="text-align: center; margin-top: 0.5rem; color: var(--text-secondary);">
                                        <span id="volumeDisplay">${Math.round(this.masterVolume * 100)}%</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="modal-section">
                                <h4>üéµ Audio Test</h4>
                                <button class="header-btn" onclick="window.gameInstance.sounds.diceRoll?.()" style="margin-right: 1rem;">Test Dice Roll</button>
                                <button class="header-btn" onclick="window.gameInstance.sounds.victory?.()">Test Victory</button>
                            </div>
                        </div>
                    </div>
                `;
                
                this.logToTerminal('üéµ Adding audio modal to DOM...');
                document.body.insertAdjacentHTML('beforeend', modalHTML);
                
                // Activate modal with animation
                setTimeout(() => {
                    const modal = document.getElementById('audioModal');
                    if (modal) {
                        modal.classList.add('active');
                        this.logToTerminal('üéµ Audio modal activated');
                    } else {
                        this.logToTerminal('‚ùå Audio modal not found after creation');
                    }
                }, 10);
                
                // Add event listeners
                this.setupAudioModalListeners();
            }

            setupAudioModalListeners() {
                document.getElementById('musicToggleModal').addEventListener('change', (e) => {
                    this.musicEnabled = e.target.checked;
                    if (this.musicEnabled) {
                        this.startBackgroundMusic();
                    } else {
                        this.stopBackgroundMusic();
                    }
                    this.logToTerminal(`üéº Background music ${this.musicEnabled ? 'enabled' : 'disabled'}`);
                });
                
                document.getElementById('soundToggleModal').addEventListener('change', (e) => {
                    this.soundEnabled = e.target.checked;
                    this.logToTerminal(`üîä Sound effects ${this.soundEnabled ? 'enabled' : 'disabled'}`);
                });
                
                document.getElementById('volumeSliderModal').addEventListener('input', (e) => {
                    this.masterVolume = e.target.value / 100;
                    document.getElementById('volumeDisplay').textContent = `${Math.round(this.masterVolume * 100)}%`;
                    if (this.backgroundMusic) {
                        this.backgroundMusic.volume = this.masterVolume * 0.3;
                    }
                });
            }

            showCustomizationModal() {
                const modalHTML = `
                    <div class="modal-overlay" id="customizationModal">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h3 class="modal-title">üé® Customization</h3>
                                <button class="modal-close" onclick="document.getElementById('customizationModal').remove()">√ó</button>
                            </div>
                            
                            <div class="modal-section">
                                <h4>ü¶Ñ Choose Your Avatar</h4>
                                <div class="avatar-grid">
                                    ${this.playerAvatars.map((avatar, index) => `
                                        <div class="avatar-option ${avatar === this.selectedAvatar ? 'selected' : ''}" 
                                             data-avatar="${avatar}" onclick="window.gameInstance.selectAvatar('${avatar}')">
                                            ${avatar}
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                            
                            <div class="modal-section">
                                <h4>üé≠ Board Theme</h4>
                                <div class="theme-grid">
                                    <div class="theme-option ${this.currentTheme === 'cyberpunk' ? 'selected' : ''}" 
                                         onclick="window.gameInstance.selectTheme('cyberpunk')">
                                        <div style="font-size: 2rem;">üåÜ</div>
                                        <div>Cyberpunk</div>
                                        <small>Neon dark with purple/cyan</small>
                                    </div>
                                    <div class="theme-option ${this.currentTheme === 'classic' ? 'selected' : ''}" 
                                         onclick="window.gameInstance.selectTheme('classic')">
                                        <div style="font-size: 2rem;">üéØ</div>
                                        <div>Classic</div>
                                        <small>Warm brown wooden</small>
                                    </div>
                                    <div class="theme-option ${this.currentTheme === 'space' ? 'selected' : ''}" 
                                         onclick="window.gameInstance.selectTheme('space')">
                                        <div style="font-size: 2rem;">üöÄ</div>
                                        <div>Space</div>
                                        <small>Cosmic dark blue</small>
                                    </div>
                                    <div class="theme-option ${this.currentTheme === 'medieval' ? 'selected' : ''}" 
                                         onclick="window.gameInstance.selectTheme('medieval')">
                                        <div style="font-size: 2rem;">üè∞</div>
                                        <div>Medieval</div>
                                        <small>Castle brown with gold</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                document.body.insertAdjacentHTML('beforeend', modalHTML);
                
                setTimeout(() => {
                    document.getElementById('customizationModal').classList.add('active');
                }, 10);
            }

            selectAvatar(avatar) {
                this.selectedAvatar = avatar;
                this.logToTerminal(`ü¶Ñ Avatar changed to ${avatar}`);
                
                // Update visual selection
                document.querySelectorAll('.avatar-option').forEach(option => {
                    option.classList.remove('selected');
                });
                document.querySelector(`[data-avatar="${avatar}"]`).classList.add('selected');
                
                // Update player avatar if already joined
                const player = this.players.find(p => p.isYou);
                if (player) {
                    player.avatar = avatar;
                    this.updateAllUI();
                }
            }

            selectTheme(theme) {
                this.currentTheme = theme;
                this.applyTheme(theme);
                this.logToTerminal(`üé≠ Theme changed to ${theme}`);
                
                // Update visual selection
                document.querySelectorAll('.theme-option').forEach(option => {
                    option.classList.remove('selected');
                });
                document.querySelector(`[onclick="window.gameInstance.selectTheme('${theme}')"]`).classList.add('selected');
            }

            showStatisticsModal() {
                const winRate = this.playerStats.gamesPlayed > 0 ? 
                    Math.round((this.playerStats.gamesWon / this.playerStats.gamesPlayed) * 100) : 0;
                
                const modalHTML = `
                    <div class="modal-overlay" id="statisticsModal">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h3 class="modal-title">üèÜ Statistics</h3>
                                <button class="modal-close" onclick="document.getElementById('statisticsModal').remove()">√ó</button>
                            </div>
                            
                            <div class="modal-section">
                                <h4>üìä Game Statistics</h4>
                                <div class="stats-grid-modal">
                                    <div class="stat-card">
                                        <div class="stat-value-large">${this.playerStats.gamesPlayed}</div>
                                        <div class="stat-label-large">Games Played</div>
                                    </div>
                                    <div class="stat-card">
                                        <div class="stat-value-large">${this.playerStats.gamesWon}</div>
                                        <div class="stat-label-large">Games Won</div>
                                    </div>
                                    <div class="stat-card">
                                        <div class="stat-value-large">${winRate}%</div>
                                        <div class="stat-label-large">Win Rate</div>
                                    </div>
                                    <div class="stat-card">
                                        <div class="stat-value-large">${this.playerStats.totalDiceRolls}</div>
                                        <div class="stat-label-large">Dice Rolls</div>
                                    </div>
                                </div>
                                
                                <div class="stats-grid-modal">
                                    <div class="stat-card">
                                        <div class="stat-value-large">${this.playerStats.snakesHit}</div>
                                        <div class="stat-label-large">üêç Snakes Hit</div>
                                    </div>
                                    <div class="stat-card">
                                        <div class="stat-value-large">${this.playerStats.laddersClimbed}</div>
                                        <div class="stat-label-large">ü™ú Ladders Climbed</div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="modal-section">
                                <h4>üéñÔ∏è Achievements</h4>
                                <div class="achievement-list">
                                    <div class="achievement-item ${this.playerStats.gamesPlayed >= 1 ? 'unlocked' : ''}">
                                        <div class="achievement-icon">üéØ</div>
                                        <div class="achievement-details">
                                            <h5>First Game</h5>
                                            <p>Play your first game</p>
                                        </div>
                                    </div>
                                    <div class="achievement-item ${this.playerStats.gamesWon >= 1 ? 'unlocked' : ''}">
                                        <div class="achievement-icon">üèÜ</div>
                                        <div class="achievement-details">
                                            <h5>Victory</h5>
                                            <p>Win your first game</p>
                                        </div>
                                    </div>
                                    <div class="achievement-item">
                                        <div class="achievement-icon">‚ö°</div>
                                        <div class="achievement-details">
                                            <h5>Speed Demon</h5>
                                            <p>Win in under 20 rolls</p>
                                        </div>
                                    </div>
                                    <div class="achievement-item ${this.playerStats.snakesHit >= 5 ? 'unlocked' : ''}">
                                        <div class="achievement-icon">üêç</div>
                                        <div class="achievement-details">
                                            <h5>Snake Charmer</h5>
                                            <p>Hit 5 snakes total (${this.playerStats.snakesHit}/5)</p>
                                        </div>
                                    </div>
                                    <div class="achievement-item ${this.playerStats.laddersClimbed >= 5 ? 'unlocked' : ''}">
                                        <div class="achievement-icon">ü™ú</div>
                                        <div class="achievement-details">
                                            <h5>Climber</h5>
                                            <p>Climb 5 ladders total (${this.playerStats.laddersClimbed}/5)</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                document.body.insertAdjacentHTML('beforeend', modalHTML);
                
                setTimeout(() => {
                    document.getElementById('statisticsModal').classList.add('active');
                }, 10);
            }

            showSettingsModal() {
                const modalHTML = `
                    <div class="modal-overlay" id="settingsModal">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h3 class="modal-title">‚öôÔ∏è Settings</h3>
                                <button class="modal-close" onclick="document.getElementById('settingsModal').remove()">√ó</button>
                            </div>
                            
                            <div class="modal-section">
                                <h4>üéÆ Gameplay</h4>
                                
                                <div class="control-group">
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="blockchainModeToggleModal" ${document.getElementById('blockchainModeToggle')?.checked || false}>
                                        <span>‚õìÔ∏è Blockchain Dice Mode</span>
                                    </label>
                                    <small style="color: var(--text-secondary); margin-left: 1.5rem;">
                                        Use on-chain dice rolls (costs MON + gas)
                                    </small>
                                </div>
                            </div>
                            
                            <div class="modal-section">
                                <h4>üìä Data</h4>
                                
                                <button class="header-btn" onclick="window.gameInstance.resetStats()" style="background: var(--accent-red); margin-right: 1rem;">
                                    üóëÔ∏è Reset Statistics
                                </button>
                                
                                <button class="header-btn" onclick="window.gameInstance.exportStats()">
                                    üì§ Export Data
                                </button>
                            </div>
                            
                            <div class="modal-section">
                                <h4>‚ÑπÔ∏è About</h4>
                                <p style="color: var(--text-secondary); line-height: 1.6;">
                                    Ultra Modern Snakes & Ladders<br>
                                    Built with Multisynq & Monad Testnet<br>
                                    Version 2.0 - Enhanced Edition<br><br>
                                    üéµ Epic Audio System<br>
                                    üé™ Advanced Animations<br>
                                    üé® Full Customization<br>
                                    üèÜ Achievement System
                                </p>
                            </div>
                        </div>
                    </div>
                `;
                
                document.body.insertAdjacentHTML('beforeend', modalHTML);
                
                setTimeout(() => {
                    document.getElementById('settingsModal').classList.add('active');
                }, 10);
                
                // Sync blockchain toggle
                document.getElementById('blockchainModeToggleModal').addEventListener('change', (e) => {
                    const mainToggle = document.getElementById('blockchainModeToggle');
                    if (mainToggle) {
                        mainToggle.checked = e.target.checked;
                    }
                });
            }

            resetStats() {
                if (confirm('Are you sure you want to reset all statistics? This cannot be undone.')) {
                    this.playerStats = {
                        gamesPlayed: 0,
                        gamesWon: 0,
                        totalDiceRolls: 0,
                        snakesHit: 0,
                        laddersClimbed: 0
                    };
                    this.savePlayerStats();
                    this.logToTerminal('üìä Statistics reset successfully');
                    
                    // Refresh stats modal if open
                    const modal = document.getElementById('statisticsModal');
                    if (modal) {
                        modal.remove();
                        this.showStatisticsModal();
                    }
                }
            }

            exportStats() {
                const data = {
                    playerStats: this.playerStats,
                    selectedAvatar: this.selectedAvatar,
                    currentTheme: this.currentTheme,
                    audioSettings: {
                        musicEnabled: this.musicEnabled,
                        soundEnabled: this.soundEnabled,
                        masterVolume: this.masterVolume
                    },
                    exportDate: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `snakes-ladders-data-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                this.logToTerminal('üì§ Game data exported successfully');
            }

            // üé≠ THEME SYSTEM
            applyTheme(theme) {
                const root = document.documentElement;
                
                switch(theme) {
                    case 'classic':
                        root.style.setProperty('--bg-primary', '#8B4513');
                        root.style.setProperty('--bg-secondary', '#A0522D');
                        root.style.setProperty('--bg-tertiary', '#CD853F');
                        root.style.setProperty('--accent-purple', '#DAA520');
                        root.style.setProperty('--accent-blue', '#4682B4');
                        root.style.setProperty('--accent-green', '#228B22');
                        break;
                        
                    case 'space':
                        root.style.setProperty('--bg-primary', '#000428');
                        root.style.setProperty('--bg-secondary', '#004e92');
                        root.style.setProperty('--bg-tertiary', '#1e3c72');
                        root.style.setProperty('--accent-purple', '#9d50bb');
                        root.style.setProperty('--accent-blue', '#6faadb');
                        root.style.setProperty('--accent-green', '#56ab2f');
                        break;
                        
                    case 'medieval':
                        root.style.setProperty('--bg-primary', '#2c1810');
                        root.style.setProperty('--bg-secondary', '#3d2818');
                        root.style.setProperty('--bg-tertiary', '#4a3520');
                        root.style.setProperty('--accent-purple', '#d4af37');
                        root.style.setProperty('--accent-blue', '#4169e1');
                        root.style.setProperty('--accent-green', '#32cd32');
                        break;
                        
                    default: // cyberpunk
                        root.style.setProperty('--bg-primary', '#0a0a0a');
                        root.style.setProperty('--bg-secondary', '#111111');
                        root.style.setProperty('--bg-tertiary', '#1a1a1a');
                        root.style.setProperty('--accent-purple', '#8b5cf6');
                        root.style.setProperty('--accent-blue', '#06b6d4');
                        root.style.setProperty('--accent-green', '#10b981');
                        break;
                }
                
                // Recreate the board with new theme
                setTimeout(() => {
                    this.createModernBoard();
                    this.addSnakesAndLadders();
                }, 100);
            }

            // üìä STATS SYSTEM (integrated with modal)
            loadPlayerStats() {
                const saved = localStorage.getItem('snakesLadders_stats');
                if (saved) {
                    this.playerStats = { ...this.playerStats, ...JSON.parse(saved) };
                }
            }

            savePlayerStats() {
                localStorage.setItem('snakesLadders_stats', JSON.stringify(this.playerStats));
                this.checkAchievements();
            }

            checkAchievements() {
                // Check for achievement unlocks and show notifications
                const achievements = [
                    { key: 'firstGame', condition: this.playerStats.gamesPlayed >= 1, name: 'üéØ First Game' },
                    { key: 'victory', condition: this.playerStats.gamesWon >= 1, name: 'üèÜ Victory' },
                    { key: 'snakeCharmer', condition: this.playerStats.snakesHit >= 5, name: 'üêç Snake Charmer' },
                    { key: 'climber', condition: this.playerStats.laddersClimbed >= 5, name: 'ü™ú Climber' }
                ];
                
                achievements.forEach(achievement => {
                    if (achievement.condition && !this.unlockedAchievements?.includes(achievement.key)) {
                        this.unlockAchievement(achievement.name);
                        if (!this.unlockedAchievements) this.unlockedAchievements = [];
                        this.unlockedAchievements.push(achievement.key);
                    }
                });
            }

            unlockAchievement(name) {
                this.logToTerminal(`üéñÔ∏è Achievement Unlocked: ${name}`);
                if (this.soundEnabled) {
                    this.sounds.notification?.();
                }
            }

            createProceduralSounds() {
                // Dice roll sound
                this.sounds.diceRoll = this.createDiceRollSound();
                
                // Snake slide sound
                this.sounds.snakeSlide = this.createSnakeSlideSound();
                
                // Ladder climb sound
                this.sounds.ladderClimb = this.createLadderClimbSound();
                
                // Victory fanfare
                this.sounds.victory = this.createVictoryFanfare();
                
                // Move sound
                this.sounds.move = this.createMoveSound();
                
                // Notification sound
                this.sounds.notification = this.createNotificationSound();
            }

            createDiceRollSound() {
                // Create a realistic dice rolling sound using white noise and filtering
                return () => {
                    if (!this.soundEnabled || !this.audioContext) return;
                    
                    const duration = 1.5;
                    const bufferSize = this.audioContext.sampleRate * duration;
                    const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                    const data = buffer.getChannelData(0);
                    
                    // Generate rolling sound with decreasing intensity
                    for (let i = 0; i < bufferSize; i++) {
                        const t = i / bufferSize;
                        const intensity = Math.exp(-t * 3) * (0.5 + 0.5 * Math.sin(t * 50));
                        data[i] = (Math.random() * 2 - 1) * intensity * 0.1;
                    }
                    
                    const source = this.audioContext.createBufferSource();
                    const filter = this.audioContext.createBiquadFilter();
                    const gainNode = this.audioContext.createGain();
                    
                    source.buffer = buffer;
                    filter.type = 'bandpass';
                    filter.frequency.value = 800;
                    filter.Q.value = 5;
                    gainNode.gain.value = this.masterVolume * 0.6;
                    
                    source.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    source.start();
                };
            }

            createSnakeSlideSound() {
                return () => {
                    if (!this.soundEnabled || !this.audioContext) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    const filter = this.audioContext.createBiquadFilter();
                    
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(600, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(200, this.audioContext.currentTime + 1.2);
                    
                    filter.type = 'lowpass';
                    filter.frequency.value = 1000;
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.masterVolume * 0.3, this.audioContext.currentTime + 0.1);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 1.2);
                    
                    oscillator.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 1.2);
                };
            }

            createLadderClimbSound() {
                return () => {
                    if (!this.soundEnabled || !this.audioContext) return;
                    
                    // Create ascending notes for ladder climbing
                    const notes = [261.63, 293.66, 329.63, 349.23, 392.00]; // C, D, E, F, G
                    
                    notes.forEach((freq, index) => {
                        setTimeout(() => {
                            const oscillator = this.audioContext.createOscillator();
                            const gainNode = this.audioContext.createGain();
                            
                            oscillator.type = 'sine';
                            oscillator.frequency.value = freq;
                            
                            gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                            gainNode.gain.linearRampToValueAtTime(this.masterVolume * 0.2, this.audioContext.currentTime + 0.05);
                            gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.25);
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(this.audioContext.destination);
                            
                            oscillator.start();
                            oscillator.stop(this.audioContext.currentTime + 0.25);
                        }, index * 100);
                    });
                };
            }

            createVictoryFanfare() {
                return () => {
                    if (!this.soundEnabled || !this.audioContext) return;
                    
                    // Victory melody
                    const melody = [
                        {freq: 523.25, duration: 0.3}, // C5
                        {freq: 659.25, duration: 0.3}, // E5
                        {freq: 783.99, duration: 0.3}, // G5
                        {freq: 1046.5, duration: 0.6}  // C6
                    ];
                    
                    let time = 0;
                    melody.forEach(note => {
                        setTimeout(() => {
                            const oscillator = this.audioContext.createOscillator();
                            const gainNode = this.audioContext.createGain();
                            
                            oscillator.type = 'triangle';
                            oscillator.frequency.value = note.freq;
                            
                            gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                            gainNode.gain.linearRampToValueAtTime(this.masterVolume * 0.4, this.audioContext.currentTime + 0.05);
                            gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + note.duration);
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(this.audioContext.destination);
                            
                            oscillator.start();
                            oscillator.stop(this.audioContext.currentTime + note.duration);
                        }, time * 1000);
                        time += note.duration;
                    });
                };
            }

            createMoveSound() {
                return () => {
                    if (!this.soundEnabled || !this.audioContext) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(440, this.audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(660, this.audioContext.currentTime + 0.2);
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.masterVolume * 0.15, this.audioContext.currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.2);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.2);
                };
            }

            createNotificationSound() {
                return () => {
                    if (!this.soundEnabled || !this.audioContext) return;
                    
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.value = 800;
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.masterVolume * 0.2, this.audioContext.currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.3);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.3);
                };
            }

            startBackgroundMusic() {
                if (!this.musicEnabled || !this.audioContext) return;
                
                this.stopBackgroundMusic(); // Stop any existing music
                
                // Create ambient cyberpunk background music
                this.createAmbientMusic();
            }

            createAmbientMusic() {
                // Create a simple ambient cyberpunk loop
                const createTone = (freq, duration, delay = 0) => {
                    setTimeout(() => {
                        if (!this.musicEnabled) return;
                        
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        const filter = this.audioContext.createBiquadFilter();
                        
                        oscillator.type = 'sine';
                        oscillator.frequency.value = freq;
                        
                        filter.type = 'lowpass';
                        filter.frequency.value = 800;
                        
                        gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                        gainNode.gain.linearRampToValueAtTime(this.masterVolume * 0.1, this.audioContext.currentTime + 1);
                        gainNode.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + duration - 1);
                        
                        oscillator.connect(filter);
                        filter.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + duration);
                    }, delay);
                };
                
                // Ambient pad progression
                const chords = [
                    [130.81, 164.81, 196.00], // C3, E3, G3
                    [146.83, 174.61, 220.00], // D3, F3, A3
                    [123.47, 155.56, 185.00], // B3, D#3, F#3
                    [110.00, 138.59, 164.81]  // A3, C#3, E3
                ];
                
                const playChordProgression = () => {
                    if (!this.musicEnabled) return;
                    
                    chords.forEach((chord, chordIndex) => {
                        chord.forEach(freq => {
                            createTone(freq, 8, chordIndex * 8000);
                        });
                    });
                    
                    // Loop the progression
                    setTimeout(playChordProgression, 32000);
                };
                
                playChordProgression();
            }

            stopBackgroundMusic() {
                // Background music will naturally stop when oscillators end
                // This method exists for future enhancement
            }

            // üé™ PARTICLE & ANIMATION SYSTEM
            initParticleSystem() {
                this.logToTerminal('‚ú® Particle system initialized');
                
                // Add particle container to game board
                const gameBoard = document.getElementById('gameBoardModern');
                const particleContainer = document.createElement('div');
                particleContainer.id = 'particleContainer';
                particleContainer.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 10;
                `;
                gameBoard.appendChild(particleContainer);
                
                // Initialize camera and screen shake
                this.setupCameraSystem();
            }

            setupCameraSystem() {
                const gameBoard = document.getElementById('gameBoardModern');
                
                // Add smooth transitions
                gameBoard.style.transition = 'transform 0.5s ease-out';
                
                // Start screen shake animation loop
                this.startScreenShakeLoop();
            }

            startScreenShakeLoop() {
                const updateScreenShake = () => {
                    if (this.screenShakeIntensity > 0) {
                        const gameBoard = document.getElementById('gameBoardModern');
                        const shakeX = (Math.random() - 0.5) * this.screenShakeIntensity;
                        const shakeY = (Math.random() - 0.5) * this.screenShakeIntensity;
                        
                        gameBoard.style.transform = `translate(${shakeX}px, ${shakeY}px)`;
                        
                        // Gradually reduce shake intensity
                        this.screenShakeIntensity *= 0.95;
                        
                        if (this.screenShakeIntensity < 0.1) {
                            this.screenShakeIntensity = 0;
                            gameBoard.style.transform = 'translate(0, 0)';
                        }
                    }
                    
                    requestAnimationFrame(updateScreenShake);
                };
                
                updateScreenShake();
            }

            createParticleExplosion(x, y, color = '#00ff88', count = 20) {
                const container = document.getElementById('particleContainer');
                if (!container) return;
                
                for (let i = 0; i < count; i++) {
                    const particle = document.createElement('div');
                    particle.style.cssText = `
                        position: absolute;
                        left: ${x}px;
                        top: ${y}px;
                        width: 6px;
                        height: 6px;
                        background: ${color};
                        border-radius: 50%;
                        pointer-events: none;
                        box-shadow: 0 0 10px ${color};
                    `;
                    
                    container.appendChild(particle);
                    
                    // Animate particle
                    const angle = (i / count) * Math.PI * 2;
                    const velocity = 50 + Math.random() * 100;
                    const vx = Math.cos(angle) * velocity;
                    const vy = Math.sin(angle) * velocity;
                    
                    particle.animate([
                        { 
                            transform: 'translate(0, 0) scale(1)',
                            opacity: 1
                        },
                        { 
                            transform: `translate(${vx}px, ${vy}px) scale(0)`,
                            opacity: 0
                        }
                    ], {
                        duration: 1000 + Math.random() * 500,
                        easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
                    }).onfinish = () => {
                        if (container.contains(particle)) {
                            container.removeChild(particle);
                        }
                    };
                }
            }

            triggerScreenShake(intensity = 10) {
                this.screenShakeIntensity = Math.max(this.screenShakeIntensity, intensity);
            }

            smoothMovePlayerToPosition(playerAddress, fromPos, toPos) {
                const playerElement = document.querySelector(`[data-player="${playerAddress}"]`);
                const fromCell = document.getElementById(`modern-cell-${fromPos}`);
                const toCell = document.getElementById(`modern-cell-${toPos}`);
                
                if (!playerElement || !fromCell || !toCell) return;
                
                // Add player trail for advanced animations
                const player = this.players.find(p => p.address === playerAddress);
                if (player && this.playerTrails) {
                    this.addPlayerTrail(player, fromPos, toPos);
                }
                
                // Get positions
                const fromRect = fromCell.getBoundingClientRect();
                const toRect = toCell.getBoundingClientRect();
                const boardRect = document.getElementById('gameBoardModern').getBoundingClientRect();
                
                const startX = fromRect.left - boardRect.left + fromRect.width / 2;
                const startY = fromRect.top - boardRect.top + fromRect.height / 2;
                const endX = toRect.left - boardRect.left + toRect.width / 2;
                const endY = toRect.top - boardRect.top + toRect.height / 2;
                
                // Create movement animation with enhanced effects
                const animation = playerElement.animate([
                    { 
                        transform: `translate(${startX - 20}px, ${startY - 20}px) scale(1)`,
                        filter: 'brightness(1) drop-shadow(0 0 5px currentColor)'
                    },
                    { 
                        transform: `translate(${endX - 20}px, ${endY - 20}px) scale(1.3)`,
                        filter: 'brightness(1.3) drop-shadow(0 0 15px currentColor)'
                    },
                    { 
                        transform: `translate(${endX - 20}px, ${endY - 20}px) scale(1)`,
                        filter: 'brightness(1) drop-shadow(0 0 5px currentColor)'
                    }
                ], {
                    duration: 1000,
                    easing: 'cubic-bezier(0.4, 0.0, 0.2, 1)'
                });
                
                // Play move sound
                this.sounds.move?.();
                
                // Create enhanced particle trail
                this.createParticleExplosion(endX, endY, this.getPlayerColor(player?.index || 0), 15);
                
                // Add screen shake for dramatic effect
                this.triggerScreenShake(2);
                
                // Show emote opportunity (random chance)
                if (Math.random() < 0.3 && this.emotePanel) {
                    setTimeout(() => {
                        this.showEmoteHint();
                    }, 1200);
                }
            }

            showEmoteHint() {
                if (this.emotePanel && this.emotePanel.style.display === 'none') {
                    // Show a quick hint about emotes
                    const hint = document.createElement('div');
                    hint.textContent = 'üí≠ Express yourself! Click to react';
                    hint.style.cssText = `
                        position: fixed;
                        bottom: 80px;
                        right: 20px;
                        background: var(--accent-purple);
                        color: white;
                        padding: 0.8rem 1.2rem;
                        border-radius: 20px;
                        font-size: 0.9rem;
                        z-index: 1001;
                        cursor: pointer;
                        animation: bounceIn 0.5s ease-out;
                    `;
                    
                    hint.addEventListener('click', () => {
                        this.toggleEmotePanel();
                        hint.remove();
                    });
                    
                    document.body.appendChild(hint);
                    
                    // Auto-remove after 3 seconds
                    setTimeout(() => {
                        if (hint.parentNode) {
                            hint.remove();
                        }
                    }, 3000);
                }
            }

            getPlayerColor(index) {
                const colors = [
                    '#8b5cf6', // Purple
                    '#06b6d4', // Cyan
                    '#10b981', // Green
                    '#f59e0b', // Orange
                    '#ef4444', // Red
                    '#8b5cf6', // Purple (repeat for more players)
                ];
                return colors[index % colors.length];
            }

            async connectWallet() {
                try {
                    this.logToTerminal('üîó Initiating MetaMask connection...');
                    
                    // Check if MetaMask is installed
                    if (typeof window.ethereum === 'undefined') {
                        this.logToTerminal('‚ùå MetaMask not detected!');
                        alert('‚ö†Ô∏è MetaMask not detected!\n\nPlease install MetaMask extension:\n1. Visit metamask.io\n2. Install the browser extension\n3. Refresh this page');
                        return;
                    }

                    // Check if MetaMask is unlocked
                    const accounts = await window.ethereum.request({ 
                        method: 'eth_accounts' 
                    });

                    if (accounts.length === 0) {
                        this.logToTerminal('üîì Requesting account access...');
                        // Request account access
                        const newAccounts = await window.ethereum.request({ 
                            method: 'eth_requestAccounts' 
                        });
                        this.playerAddress = newAccounts[0];
                    } else {
                        this.playerAddress = accounts[0];
                    }

                    this.logToTerminal(`üéØ Connected to: ${this.shortAddress(this.playerAddress)}`);

                    // Check current network
                    const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                    this.logToTerminal(`üåê Current network: ${chainId}`);
                    
                    if (chainId !== '0x279F') {
                        this.logToTerminal('üîÑ Switching to Monad Testnet...');
                        await this.switchToMonadTestnet();
                    } else {
                        this.logToTerminal('‚úÖ Already on Monad Testnet');
                    }

                    // Initialize smart contract
                    await this.initContract();

                    // Get balance
                    try {
                        const balance = await window.ethereum.request({
                            method: 'eth_getBalance',
                            params: [this.playerAddress, 'latest']
                        });
                        
                        const balanceInMon = parseInt(balance, 16) / Math.pow(10, 18);
                        this.updateWalletUI(balanceInMon);
                        this.logToTerminal(`üí∞ Balance: ${balanceInMon.toFixed(4)} MON`);
                    } catch (balanceError) {
                        this.logToTerminal('‚ö†Ô∏è Could not fetch balance');
                        this.updateWalletUI(0);
                    }

                    this.logToTerminal('ÔøΩ Wallet connection complete!');
                    this.logToTerminal('üéÆ Ready to join the game!');

                } catch (error) {
                    console.error('Wallet connection failed:', error);
                    this.logToTerminal(`‚ùå Connection failed: ${error.message}`);
                    
                    // Handle specific errors
                    if (error.code === 4001) {
                        this.logToTerminal('üë§ User rejected the connection request');
                        alert('‚ö†Ô∏è Connection rejected!\n\nTo play the game, please:\n1. Click "Connect MetaMask" again\n2. Approve the connection request');
                    } else if (error.code === -32002) {
                        this.logToTerminal('‚è≥ Connection request already pending');
                        alert('‚ö†Ô∏è Connection request pending!\n\nPlease check MetaMask and approve the pending request.');
                    } else {
                        alert(`‚ùå Wallet connection failed!\n\nError: ${error.message}\n\nTry refreshing the page and connecting again.`);
                    }
                }
            }

            async initContract() {
                try {
                    if (typeof window.ethereum !== 'undefined' && this.playerAddress) {
                        this.logToTerminal('üìã Blockchain interface ready');
                        return true;
                    }
                } catch (error) {
                    console.error('Contract initialization failed:', error);
                    this.logToTerminal(`‚ùå Contract init failed: ${error.message}`);
                    return false;
                }
            }

            async waitForTransaction(txHash) {
                return new Promise((resolve, reject) => {
                    let attempts = 0;
                    const maxAttempts = 30; // 30 seconds timeout
                    
                    const checkTransaction = async () => {
                        attempts++;
                        
                        try {
                            const receipt = await window.ethereum.request({
                                method: 'eth_getTransactionReceipt',
                                params: [txHash]
                            });
                            
                            if (receipt) {
                                if (receipt.status === '0x1') {
                                    resolve(receipt);
                                } else {
                                    reject(new Error('Transaction failed'));
                                }
                            } else if (attempts >= maxAttempts) {
                                reject(new Error('Transaction timeout'));
                            } else {
                                setTimeout(checkTransaction, 1000);
                            }
                        } catch (error) {
                            if (attempts >= maxAttempts) {
                                reject(error);
                            } else {
                                setTimeout(checkTransaction, 1000);
                            }
                        }
                    };
                    
                    setTimeout(checkTransaction, 1000);
                });
            }

            async switchToMonadTestnet() {
                try {
                    this.logToTerminal('üîÑ Attempting to switch to Monad Testnet...');
                    
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: '0x279F' }],
                    });
                    
                    this.logToTerminal('‚úÖ Successfully switched to Monad Testnet');
                    
                } catch (switchError) {
                    this.logToTerminal(`‚ö†Ô∏è Switch error: ${switchError.message}`);
                    
                    if (switchError.code === 4902) {
                        // Network not added yet, try to add it
                        this.logToTerminal('‚ûï Adding Monad Testnet to MetaMask...');
                        
                        try {
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: '0x279F',
                                    chainName: 'Monad Testnet',
                                    rpcUrls: ['https://testnet-rpc.monad.xyz'],
                                    nativeCurrency: {
                                        name: 'MON',
                                        symbol: 'MON',
                                        decimals: 18
                                    },
                                    blockExplorerUrls: ['https://testnet.monadexplorer.com/']
                                }]
                            });
                            
                            this.logToTerminal('‚úÖ Monad Testnet added and connected successfully');
                            
                        } catch (addError) {
                            this.logToTerminal(`‚ùå Failed to add Monad Testnet: ${addError.message}`);
                            throw new Error('Failed to add Monad Testnet to MetaMask');
                        }
                    } else if (switchError.code === 4001) {
                        this.logToTerminal('üë§ User rejected network switch');
                        throw new Error('Network switch rejected by user');
                    } else {
                        this.logToTerminal(`‚ùå Network switch failed: ${switchError.message}`);
                        throw switchError;
                    }
                }
            }

            generateRoomCode() {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                let result = '';
                for (let i = 0; i < 6; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result;
            }

            async createRoom() {
                if (!this.playerAddress) {
                    alert('‚ö†Ô∏è Connect your wallet first!');
                    return;
                }

                try {
                    this.roomId = this.generateRoomCode();
                    this.isHost = true;
                    
                    // Clear any AI players immediately
                    this.clearAIPlayers();
                    
                    this.logToTerminal(`üéØ Creating room with code: ${this.roomId}`);
                    this.logToTerminal('üö´ AI players disabled for multiplayer room');
                    
                    // Start AI prevention monitor
                    this.startAIPreventionMonitor();
                    
                    // Update UI
                    document.getElementById('roomCodeText').textContent = this.roomId;
                    document.getElementById('roomCodeDisplay').style.display = 'block';
                    document.getElementById('joinRoomSection').style.display = 'none';
                    document.getElementById('roomInfo').style.display = 'block';
                    document.getElementById('roomStatusText').textContent = `Room created! Click "JOIN GAME" to enter, then share code "${this.roomId}" with friends.`;
                    
                    // Register room with backend service
                    if (this.backendConnected) {
                        try {
                            const response = await fetch('http://localhost:3001/join-room', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ 
                                    roomCode: this.roomId,
                                    playerAddress: this.playerAddress,
                                    playerName: `Player-${this.shortAddress(this.playerAddress)}`,
                                    isHost: true
                                })
                            });
                            
                            if (response.ok) {
                                this.logToTerminal('‚úÖ Room registered with multiplayer service');
                                this.startPollingForPlayers();
                            } else {
                                this.logToTerminal('‚ö†Ô∏è Failed to register room, using local mode');
                            }
                        } catch (error) {
                            this.logToTerminal('‚ö†Ô∏è Backend service error, using local mode');
                        }
                    }
                    
                    // DON'T automatically join the game - let user click JOIN GAME button
                    // this.processJoinGame(); // REMOVED - prevents duplicate players
                    
                    this.logToTerminal('üéÆ Room created! Click "JOIN GAME" to enter, then share room code with friends.');
                    this.logToTerminal(`üìã Room Code: ${this.roomId} (share this with friends)`);
                    
                } catch (error) {
                    console.error('Room creation failed:', error);
                    this.logToTerminal(`‚ùå Room creation failed: ${error.message}`);
                    alert('Failed to create room. Please try again.');
                }
            }

            async joinRoom() {
                const roomCode = document.getElementById('roomCodeInput').value.trim().toUpperCase();
                
                if (!this.playerAddress) {
                    alert('‚ö†Ô∏è Connect your wallet first!');
                    return;
                }
                
                if (!roomCode || roomCode.length !== 6) {
                    alert('‚ö†Ô∏è Please enter a valid 6-character room code!');
                    return;
                }

                try {
                    // Clear any existing AI players before joining room
                    this.clearAIPlayers();
                    
                    this.roomId = roomCode;
                    this.isHost = false;
                    
                    this.logToTerminal(`üîç Joining room: ${roomCode}`);
                    this.logToTerminal('üö´ AI players disabled for multiplayer room');
                    
                    // Start AI prevention monitor
                    this.startAIPreventionMonitor();
                    
                    // Update UI
                    document.getElementById('joinRoomSection').style.display = 'none';
                    document.getElementById('roomInfo').style.display = 'block';
                    document.getElementById('roomStatusText').textContent = `Joined room "${roomCode}"! Waiting for game to start...`;
                    
                    // Register with backend service
                    if (this.backendConnected) {
                        try {
                            const response = await fetch('http://localhost:3001/join-room', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ 
                                    roomCode: this.roomId,
                                    playerAddress: this.playerAddress,
                                    playerName: `Player-${this.shortAddress(this.playerAddress)}`,
                                    isHost: false
                                })
                            });
                            
                            if (response.ok) {
                                const result = await response.json();
                                this.logToTerminal('‚úÖ Successfully joined room via multiplayer service');
                                
                                // Load existing players from backend
                                if (result.existingPlayers) {
                                    this.loadExistingPlayers(result.existingPlayers);
                                }
                                
                                this.startPollingForPlayers();
                            } else {
                                this.logToTerminal('‚ö†Ô∏è Failed to join room, using local mode');
                            }
                        } catch (error) {
                            this.logToTerminal('‚ö†Ô∏è Backend service error, using local mode');
                        }
                    }
                    
                    // Add yourself to the game
                    this.processJoinGame();
                    
                    this.logToTerminal('üéÆ Room joined! Ready to play with friends.');
                    
                } catch (error) {
                    console.error('Room join failed:', error);
                    this.logToTerminal(`‚ùå Failed to join room: ${error.message}`);
                    alert('Failed to join room. Please check the code and try again.');
                }
            }

            loadExistingPlayers(existingPlayers) {
                this.logToTerminal(`üì• Loading ${existingPlayers.length} existing players...`);
                
                existingPlayers.forEach(playerData => {
                    if (playerData.playerAddress !== this.playerAddress) {
                        const existingPlayer = this.players.find(p => p.address === playerData.playerAddress);
                        if (!existingPlayer) {
                            const newPlayer = {
                                name: playerData.playerName || `Player-${this.shortAddress(playerData.playerAddress)}`,
                                address: playerData.playerAddress,
                                isYou: false,
                                isBot: false,
                                id: playerData.playerAddress
                            };
                            this.players.push(newPlayer);
                            this.playerPositions[playerData.playerAddress] = 1;
                            this.logToTerminal(`‚ûï Added existing player: ${newPlayer.name}`);
                        }
                    }
                });
                
                this.updateRoomStatus();
                this.updateAllUI();
            }

            startPollingForPlayers() {
                if (this.playerPollingInterval) {
                    clearInterval(this.playerPollingInterval);
                }
                
                this.playerPollingInterval = setInterval(async () => {
                    try {
                        const response = await fetch(`http://localhost:3001/game/${this.roomId}`);
                        if (response.ok) {
                            const gameData = await response.json();
                            if (gameData.players) {
                                this.syncPlayersFromBackend(gameData.players);
                            }
                            // Sync dice events
                            await this.syncDiceEventsFromBackend(gameData);
                        }
                    } catch (error) {
                        // Silently fail - polling is optional
                    }
                }, 2000); // Poll every 2 seconds
                
                this.logToTerminal('üîÑ Started polling for player and dice updates');
            }

            syncPlayersFromBackend(backendPlayers) {
                let playersAdded = 0;
                
                backendPlayers.forEach(playerData => {
                    const existingPlayer = this.players.find(p => p.address === playerData.playerAddress);
                    if (!existingPlayer && playerData.playerAddress !== this.playerAddress) {
                        const newPlayer = {
                            name: playerData.playerName || `Player-${this.shortAddress(playerData.playerAddress)}`,
                            address: playerData.playerAddress,
                            isYou: false,
                            isBot: false,
                            id: playerData.playerAddress
                        };
                        this.players.push(newPlayer);
                        this.playerPositions[playerData.playerAddress] = 1;
                        playersAdded++;
                        this.logToTerminal(`üéâ ${newPlayer.name} joined the room!`);
                    }
                });
                
                if (playersAdded > 0) {
                    this.updateRoomStatus();
                    this.updateAllUI();
                }
            }

            async syncDiceEventsFromBackend(gameData) {
                if (gameData.diceEvents && gameData.diceEvents.length > 0) {
                    const lastProcessedTime = this.lastDiceEventTime || 0;
                    const newEvents = gameData.diceEvents.filter(event => 
                        event.timestamp > lastProcessedTime && 
                        event.playerAddress !== this.playerAddress
                    );
                    
                    for (const event of newEvents) {
                        this.logToTerminal(`üé≤ ${event.playerName} rolled ${event.roll}!`);
                        
                        // Show dice animation for other players
                        if (event.showAnimation) {
                            this.playDiceAnimationForPlayer(event.playerAddress, event.roll);
                            
                            // Also animate the main dice to show what they rolled
                            this.animateMainDiceForOtherPlayer(event.roll, event.playerName);
                        }
                        
                        // Update player position if provided
                        if (event.position) {
                            this.playerPositions[event.playerAddress] = event.position;
                        }
                        
                        if (event.blockchain && event.txHash) {
                            this.logToTerminal(`üîó Blockchain roll: ${event.txHash.substring(0, 20)}...`);
                        }
                    }
                    
                    if (newEvents.length > 0) {
                        this.lastDiceEventTime = Math.max(...newEvents.map(e => e.timestamp));
                        this.updateAllUI();
                    }
                }
                
                // Sync turn management from backend
                if (gameData.currentTurnPlayer && gameData.turnOrder) {
                    const backendTurnIndex = gameData.turnOrder.indexOf(gameData.currentTurnPlayer);
                    const localPlayerIndex = this.players.findIndex(p => p.address === gameData.currentTurnPlayer);
                    
                    if (backendTurnIndex !== -1 && localPlayerIndex !== -1 && this.currentPlayerIndex !== localPlayerIndex) {
                        this.currentPlayerIndex = localPlayerIndex;
                        const currentPlayer = this.players[this.currentPlayerIndex];
                        this.logToTerminal(`üëâ ${currentPlayer.name}'s turn (synced from server)`);
                        this.updateAllUI();
                    }
                }
                
                // Sync game start status
                if (gameData.status === 'active' && !this.gameStarted) {
                    this.gameStarted = true;
                    this.logToTerminal('üöÄ Game started by host! (synced from server)');
                    this.updateAllUI();
                }
            }

            stopPollingForPlayers() {
                if (this.playerPollingInterval) {
                    clearInterval(this.playerPollingInterval);
                    this.playerPollingInterval = null;
                    this.logToTerminal('üîÑ Stopped polling for players');
                }
            }

            startAIPreventionMonitor() {
                // Monitor every 2 seconds to ensure no AI players are added
                if (this.aiPreventionInterval) {
                    clearInterval(this.aiPreventionInterval);
                }
                
                this.aiPreventionInterval = setInterval(() => {
                    if (this.roomId && this.roomId.length === 6) {
                        const aiBots = this.players.filter(p => p.isBot);
                        if (aiBots.length > 0) {
                            this.logToTerminal(`üö® ALERT: Removing ${aiBots.length} AI bot(s) from multiplayer room!`);
                            this.clearAIPlayers();
                        }
                    }
                }, 2000);
                
                this.logToTerminal('üõ°Ô∏è AI prevention monitor started');
            }

            clearAIPlayers() {
                const originalLength = this.players.length;
                this.players = this.players.filter(player => !player.isBot);
                const removedCount = originalLength - this.players.length;
                
                if (removedCount > 0) {
                    this.logToTerminal(`üßπ Removed ${removedCount} AI player(s) for multiplayer mode`);
                    
                    // Clear AI player positions
                    for (const address in this.playerPositions) {
                        const player = this.players.find(p => p.address === address);
                        if (!player) {
                            delete this.playerPositions[address];
                        }
                    }
                    
                    this.updateAllUI();
                }
            }

            stopAIPreventionMonitor() {
                if (this.aiPreventionInterval) {
                    clearInterval(this.aiPreventionInterval);
                    this.aiPreventionInterval = null;
                    this.logToTerminal('üõ°Ô∏è AI prevention monitor stopped');
                }
                
                // Also stop player polling
                this.stopPollingForPlayers();
            }

            async connectMultisynq() {
                try {
                    this.updateMultisynqStatus('connecting');
                    this.logToTerminal('üåê Connecting to local multiplayer service...');

                    // Test backend service connection
                    const response = await fetch('http://localhost:3001/health');
                    if (response.ok) {
                        this.logToTerminal('‚úÖ Local multiplayer service connected!');
                        this.updateMultisynqStatus('online');
                        this.logToTerminal('üéØ Ready to create or join a room!');
                        this.backendConnected = true;
                    } else {
                        throw new Error('Backend service not responding');
                    }

                } catch (error) {
                    console.error('Backend connection failed:', error);
                    this.logToTerminal(`‚ùå Connection failed: ${error.message}`);
                    this.logToTerminal('üéÆ Playing in offline mode');
                    this.updateMultisynqStatus('offline');
                    this.backendConnected = false;
                }
            }

            async createGameRoom() {
                // This is now called from createRoom() with the generated room code
                if (!this.roomId) {
                    this.roomId = this.generateRoomCode();
                }
                
                this.logToTerminal(`üéØ Setting up room: ${this.roomId}`);
                
                try {
                    if (this.multisynqClient && typeof this.multisynqClient.joinRoom === 'function') {
                        await this.multisynqClient.joinRoom(this.roomId);
                        this.logToTerminal('üöÄ Room connected successfully!');
                    }
                    
                    this.setupMultisynqEvents();
                    
                } catch (error) {
                    console.error('Room setup failed:', error);
                    this.logToTerminal(`‚ùå Room setup failed: ${error.message}`);
                    this.logToTerminal('üéÆ Continuing in local mode');
                }
            }

            setupMultisynqEvents() {
                if (!this.multisynqClient) return;
                
                this.logToTerminal('üîß Setting up real-time event handlers...');
                
                this.multisynqClient.on('gameEvent', (data) => {
                    this.handleMultisynqEvent(data);
                });
                
                // Request existing players when joining a room
                if (this.roomId && this.roomId.length === 6) {
                    setTimeout(() => {
                        this.requestExistingPlayers();
                    }, 1000);
                }
            }

            sendPlayerInfo() {
                if (this.multisynqClient && this.playerAddress) {
                    const myPlayer = this.players.find(p => p.address === this.playerAddress);
                    if (myPlayer) {
                        this.multisynqClient.emit('gameEvent', {
                            type: 'playerInfo',
                            playerName: myPlayer.name,
                            playerAddress: this.playerAddress,
                            position: this.playerPositions[this.playerAddress] || 1,
                            roomId: this.roomId,
                            timestamp: Date.now()
                        });
                        this.logToTerminal('üì§ Sent my player info to room');
                    }
                }
            }

            updateRoomStatus() {
                const statusElement = document.getElementById('roomStatusText');
                if (statusElement && this.roomId && this.roomId.length === 6) {
                    const realPlayers = this.players.filter(p => !p.isBot);
                    statusElement.textContent = `In room "${this.roomId}" - ${realPlayers.length} player(s) connected`;
                    this.logToTerminal(`üìä Room status: ${realPlayers.length} real players connected`);
                }
            }

            requestExistingPlayers() {
                if (this.multisynqClient) {
                    this.logToTerminal('üîç Requesting existing players in room...');
                    this.multisynqClient.emit('gameEvent', {
                        type: 'requestPlayers',
                        requesterAddress: this.playerAddress,
                        roomId: this.roomId,
                        timestamp: Date.now()
                    });
                }
            }

            handleMultisynqEvent(data) {
                switch (data.type) {
                    case 'playerJoined':
                        this.logToTerminal(`üëã ${data.playerName} joined the room!`);
                        // Add the real player to our local game state
                        if (!this.players.find(p => p.address === data.playerAddress)) {
                            const newPlayer = {
                                name: data.playerName,
                                address: data.playerAddress,
                                isYou: data.playerAddress === this.playerAddress,
                                isBot: false,
                                id: data.playerAddress
                            };
                            this.players.push(newPlayer);
                            this.playerPositions[data.playerAddress] = 1;
                            
                            // Update room status
                            this.updateRoomStatus();
                            
                            this.logToTerminal(`üéÆ Room now has ${this.players.length} players total`);
                            this.updateAllUI();
                            
                            // Respond with your own player info if you're already in the game
                            if (this.players.find(p => p.address === this.playerAddress)) {
                                this.sendPlayerInfo();
                            }
                        }
                        break;
                        
                    case 'requestPlayers':
                        if (data.requesterAddress !== this.playerAddress) {
                            this.logToTerminal(`üîç ${data.requesterAddress} is requesting player list`);
                            this.sendPlayerInfo();
                        }
                        break;
                        
                    case 'playerInfo':
                        if (data.playerAddress !== this.playerAddress) {
                            this.logToTerminal(`üìã Received player info from ${data.playerName}`);
                            // Add this player if not already present
                            if (!this.players.find(p => p.address === data.playerAddress)) {
                                const newPlayer = {
                                    name: data.playerName,
                                    address: data.playerAddress,
                                    isYou: false,
                                    isBot: false,
                                    id: data.playerAddress
                                };
                                this.players.push(newPlayer);
                                this.playerPositions[data.playerAddress] = data.position || 1;
                                
                                this.logToTerminal(`‚ûï Added existing player: ${data.playerName}`);
                                this.updateRoomStatus();
                                this.updateAllUI();
                            }
                        }
                        break;
                        
                    case 'gameStarted':
                        this.logToTerminal('üöÄ Game started by host!');
                        if (!this.gameStarted) {
                            this.gameStarted = true;
                            this.updateAllUI();
                        }
                        break;
                        
                    case 'diceRolled':
                        this.logToTerminal(`üé≤ ${data.playerName} rolled ${data.roll}!`);
                        // Handle remote player dice rolls
                        if (data.playerAddress !== this.playerAddress) {
                            const player = this.players.find(p => p.address === data.playerAddress);
                            if (player) {
                                this.processDiceResult(player, data.roll, data.txHash);
                            }
                        }
                        break;
                }
            }

            enableDemoMode() {
                this.logToTerminal('ü§ñ Demo mode check: ' + (this.roomId || 'no room'));
                
                // NEVER add AI players if we have a 6-character room code (friend rooms)
                if (this.roomId && this.roomId.length === 6) {
                    this.logToTerminal('üö´ Room code detected - NO AI players will be added');
                    this.logToTerminal('üéÆ Multiplayer mode: Waiting for real players only');
                    this.updateMultisynqStatus('offline');
                    return; // Exit early - no demo mode
                }
                
                // Only add AI players if no room code is being used (truly solo play)
                if (!this.roomId || this.roomId.startsWith('demo-')) {
                    this.roomId = `demo-${Math.random().toString(36).substring(2, 8)}`;
                    this.updateMultisynqStatus('offline');
                    
                    this.logToTerminal('ü§ñ Solo mode detected - adding AI opponents');
                    // Add AI players for demo ONLY in solo mode
                    setTimeout(() => this.addAIPlayer('ü§ñ CyberBot', '0x7890abcdef'), 1500);
                    setTimeout(() => this.addAIPlayer('‚ö° NeuralNet', '0x1234567890'), 2500);
                } else {
                    // In room mode, just log that we're in local mode without Multisynq
                    this.logToTerminal('üéÆ Room mode: Playing with friends (no AI players)');
                    this.updateMultisynqStatus('offline');
                }
            }

            addAIPlayer(name, address) {
                const aiPlayer = {
                    name: name,
                    address: address,
                    isYou: false,
                    isBot: true,
                    id: `ai-${Date.now()}`
                };
                
                this.players.push(aiPlayer);
                this.playerPositions[aiPlayer.address] = 1;
                this.logToTerminal(`ü§ñ ${name} connected to the game`);
                this.updateAllUI();
            }

            async joinGame() {
                if (!this.playerAddress) {
                    alert('‚ö†Ô∏è Connect your wallet first!');
                    return;
                }

                if (this.players.find(p => p.address === this.playerAddress)) {
                    alert('‚ÑπÔ∏è You have already joined the game!');
                    return;
                }

                try {
                    this.logToTerminal('üîó Joining game via blockchain transaction...');
                    this.logToTerminal('üí∞ Cost: 0.05 MON + gas fees');
                    
                    // Create transaction with current network gas settings
                    const joinTx = {
                        to: this.contractAddress,
                        from: this.playerAddress,
                        value: '0xB1A2BC2EC50000', // 0.05 MON in wei
                        data: '0x0c6e7a1d', // joinGame() function selector
                        gas: '0x15F90', // 90,000 gas limit (reduced)
                        gasPrice: '0x12A05F200' // 80 Gwei (reduced gas price)
                    };
                    
                    this.logToTerminal('üìã Sending transaction to Monad Testnet...');
                    
                    const txHash = await window.ethereum.request({
                        method: 'eth_sendTransaction',
                        params: [joinTx]
                    });
                    
                    this.logToTerminal(`üìù Transaction sent: ${txHash.substring(0, 20)}...`);
                    this.logToTerminal('‚è≥ Waiting for confirmation...');
                    
                    // Wait for transaction confirmation
                    this.waitForTransaction(txHash).then(() => {
                        this.logToTerminal('‚úÖ Transaction confirmed! Welcome to the game!');
                        this.processJoinGame();
                    }).catch((error) => {
                        this.logToTerminal(`‚ùå Transaction failed: ${error.message}`);
                        this.logToTerminal('üéÆ Continuing with local game mode...');
                        this.processJoinGame();
                    });
                    
                } catch (error) {
                    console.error('Join game failed:', error);
                    this.logToTerminal(`‚ùå Transaction failed: ${error.message}`);
                    this.logToTerminal('üéÆ Continuing with local game mode...');
                    
                    // Always allow local join as fallback
                    this.processJoinGame();
                }
            }

            processJoinGame() {
                // üéµ Play join sound
                this.sounds.notification?.();
                
                const playerName = `Player-${this.shortAddress(this.playerAddress)}`;
                const newPlayer = {
                    name: playerName,
                    address: this.playerAddress,
                    isYou: true,
                    isBot: false,
                    id: this.playerAddress,
                    avatar: this.selectedAvatar || this.playerAvatars[0]
                };
                
                this.players.push(newPlayer);
                this.playerPositions[this.playerAddress] = 1;
                
                if (this.players.length === 1) {
                    this.isHost = true;
                    this.logToTerminal('üëë You are now the game host!');
                }
                
                this.logToTerminal(`üéØ Successfully joined as ${playerName}!`);
                
                // Broadcast to Multisynq to let other players know you joined
                if (this.multisynqClient) {
                    try {
                        this.multisynqClient.emit('gameEvent', {
                            type: 'playerJoined',
                            playerName: playerName,
                            playerAddress: this.playerAddress,
                            roomId: this.roomId,
                            timestamp: Date.now()
                        });
                        this.logToTerminal('üì° Notified other players in the room');
                    } catch (error) {
                        console.log('Broadcast failed:', error);
                        this.logToTerminal('‚ö†Ô∏è Could not notify other players (local mode)');
                    }
                } else {
                    this.logToTerminal('‚ö†Ô∏è Playing in local mode - friends need to use same room code');
                }
                
                // Update room status if in a friend's room
                if (this.roomId && this.roomId.length === 6) {
                    const statusElement = document.getElementById('roomStatusText');
                    if (statusElement) {
                        statusElement.textContent = `In room "${this.roomId}" - ${this.players.length} player(s) joined`;
                    }
                }
                
                this.updateAllUI();
            }

            async startGame() {
                // Clear AI players if this is a multiplayer room
                if (this.roomId && this.roomId.length === 6) {
                    this.clearAIPlayers();
                    this.logToTerminal('üö´ AI players removed for multiplayer mode');
                }
                
                if (this.players.length < 2) {
                    alert('‚ö†Ô∏è Need at least 2 players to start the game!');
                    return;
                }

                try {
                    this.logToTerminal('üöÄ Starting game...');
                    
                    // Notify backend about game start
                    if (this.backendConnected && this.isHost) {
                        try {
                            await fetch('http://localhost:3001/start-game', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    roomCode: this.roomId,
                                    hostAddress: this.playerAddress
                                })
                            });
                            this.logToTerminal('üì° Game start broadcasted to server');
                        } catch (error) {
                            this.logToTerminal('‚ö†Ô∏è Failed to notify server of game start');
                        }
                    }
                    
                    this.gameStarted = true;
                    this.totalGames++;
                    this.currentRound = 1;
                    
                    this.logToTerminal(`üöÄ Game #${this.totalGames} started!`);
                    this.logToTerminal(`üéØ ${this.players[0].name} will go first`);
                    
                    // Broadcast game start (legacy Multisynq)
                    if (this.multisynqClient) {
                        try {
                            this.multisynqClient.emit('gameEvent', {
                                type: 'gameStarted',
                                gameNumber: this.totalGames,
                                players: this.players,
                                host: this.playerAddress,
                                roomId: this.roomId
                            });
                        } catch (error) {
                            console.log('Broadcast failed:', error);
                        }
                    }
                    
                    this.updateAllUI();
                    
                    // Auto-roll for AI if they're first
                    if (this.players[0].isBot) {
                        setTimeout(() => this.rollDice(), 2000);
                    }
                    
                } catch (error) {
                    console.error('Start game failed:', error);
                    this.logToTerminal(`‚ùå Start game failed: ${error.message}`);
                }
            }

            // Full-screen dice animation
            async showFullScreenDiceAnimation(result, isBlockchain = false) {
                return new Promise((resolve) => {
                    // Create full-screen overlay
                    const overlay = document.createElement('div');
                    overlay.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100vw;
                        height: 100vh;
                        background: rgba(0, 0, 0, 0.95);
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        z-index: 10000;
                        backdrop-filter: blur(15px);
                    `;

                    // Create dice container
                    const diceContainer = document.createElement('div');
                    diceContainer.style.cssText = `
                        position: relative;
                        perspective: 1200px;
                        transform-style: preserve-3d;
                    `;

                    // Create 3D dice
                    const dice = document.createElement('div');
                    dice.style.cssText = `
                        width: 200px;
                        height: 200px;
                        position: relative;
                        transform-style: preserve-3d;
                        animation: rollDiceBig 3s ease-in-out;
                        margin: 20px auto;
                    `;

                    // Create dice faces with dots
                    const faces = ['front', 'back', 'right', 'left', 'top', 'bottom'];
                    const diceValues = [1, 2, 3, 4, 5, 6];
                    const dotPatterns = {
                        1: [[1,1]], // center
                        2: [[0,0], [2,2]], // diagonal
                        3: [[0,0], [1,1], [2,2]], // diagonal
                        4: [[0,0], [0,2], [2,0], [2,2]], // corners
                        5: [[0,0], [0,2], [1,1], [2,0], [2,2]], // corners + center
                        6: [[0,0], [0,2], [1,0], [1,2], [2,0], [2,2]] // two columns
                    };

                    faces.forEach((face, index) => {
                        const faceElement = document.createElement('div');
                        faceElement.className = `dice-face-big dice-${face}`;
                        faceElement.style.cssText = `
                            position: absolute;
                            width: 200px;
                            height: 200px;
                            background: linear-gradient(145deg, #ffffff, #f0f0f0);
                            border: 4px solid #333;
                            border-radius: 25px;
                            display: grid;
                            grid-template-columns: repeat(3, 1fr);
                            grid-template-rows: repeat(3, 1fr);
                            gap: 5px;
                            padding: 25px;
                            box-shadow: inset 0 0 30px rgba(0,0,0,0.1);
                            ${isBlockchain ? 'box-shadow: inset 0 0 30px rgba(0,255,255,0.3), 0 0 50px rgba(0,255,255,0.5);' : ''}
                        `;

                        // Position faces in 3D
                        const transforms = {
                            front: 'rotateY(0deg) translateZ(100px)',
                            back: 'rotateY(180deg) translateZ(100px)',
                            right: 'rotateY(90deg) translateZ(100px)',
                            left: 'rotateY(-90deg) translateZ(100px)',
                            top: 'rotateX(90deg) translateZ(100px)',
                            bottom: 'rotateX(-90deg) translateZ(100px)'
                        };
                        faceElement.style.transform = transforms[face];

                        // Add dots for each face
                        const faceValue = diceValues[index];
                        const dots = dotPatterns[faceValue] || [];
                        
                        for (let row = 0; row < 3; row++) {
                            for (let col = 0; col < 3; col++) {
                                const dot = document.createElement('div');
                                const shouldShow = dots.some(([r, c]) => r === row && c === col);
                                dot.style.cssText = `
                                    width: 25px;
                                    height: 25px;
                                    border-radius: 50%;
                                    background: ${shouldShow ? '#333' : 'transparent'};
                                    box-shadow: ${shouldShow && isBlockchain ? '0 0 10px rgba(0,255,255,0.8)' : 'none'};
                                `;
                                faceElement.appendChild(dot);
                            }
                        }

                        dice.appendChild(faceElement);
                    });

                    // Create result display
                    const resultDisplay = document.createElement('div');
                    resultDisplay.style.cssText = `
                        color: #fff;
                        font-size: 54px;
                        font-weight: bold;
                        text-align: center;
                        margin-top: 50px;
                        text-shadow: 0 0 30px rgba(255,255,255,0.8);
                        opacity: 0;
                        animation: fadeInResult 1s ease-in-out 2.5s forwards;
                        ${isBlockchain ? 'color: #00ffff; text-shadow: 0 0 30px rgba(0,255,255,0.8);' : ''}
                    `;
                    resultDisplay.innerHTML = `
                        ${isBlockchain ? '‚õìÔ∏è BLOCKCHAIN DICE ‚õìÔ∏è<br>' : 'üé≤ YOU ROLLED üé≤<br>'}
                        <span style="font-size: 72px; ${isBlockchain ? 'text-shadow: 0 0 40px rgba(0,255,255,1);' : ''}">${result}</span>
                    `;

                    // Add blockchain glow effect
                    if (isBlockchain) {
                        const glowEffect = document.createElement('div');
                        glowEffect.style.cssText = `
                            position: absolute;
                            width: 350px;
                            height: 350px;
                            border-radius: 50%;
                            background: radial-gradient(circle, rgba(0,255,255,0.3) 0%, transparent 70%);
                            animation: blockchainGlow 2s ease-in-out infinite alternate;
                            z-index: -1;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                        `;
                        diceContainer.appendChild(glowEffect);
                    }

                    diceContainer.appendChild(dice);
                    diceContainer.appendChild(resultDisplay);
                    overlay.appendChild(diceContainer);

                    // Add animations to head if not exists
                    if (!document.querySelector('#fullscreen-dice-styles')) {
                        const style = document.createElement('style');
                        style.id = 'fullscreen-dice-styles';
                        style.textContent = `
                            @keyframes rollDiceBig {
                                0% { transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg) scale(0.5); }
                                20% { transform: rotateX(180deg) rotateY(180deg) rotateZ(90deg) scale(0.8); }
                                40% { transform: rotateX(360deg) rotateY(360deg) rotateZ(180deg) scale(1.1); }
                                60% { transform: rotateX(540deg) rotateY(540deg) rotateZ(270deg) scale(1.2); }
                                80% { transform: rotateX(720deg) rotateY(720deg) rotateZ(360deg) scale(1.1); }
                                100% { transform: rotateX(720deg) rotateY(720deg) rotateZ(360deg) scale(1); }
                            }
                            @keyframes fadeInResult {
                                from { opacity: 0; transform: translateY(30px) scale(0.8); }
                                to { opacity: 1; transform: translateY(0) scale(1); }
                            }
                            @keyframes blockchainGlow {
                                from { 
                                    box-shadow: 0 0 30px rgba(0,255,255,0.4);
                                    transform: translate(-50%, -50%) scale(1);
                                }
                                to { 
                                    box-shadow: 0 0 80px rgba(0,255,255,0.8);
                                    transform: translate(-50%, -50%) scale(1.1);
                                }
                            }
                        `;
                        document.head.appendChild(style);
                    }

                    document.body.appendChild(overlay);

                    // Remove overlay after animation
                    setTimeout(() => {
                        overlay.style.opacity = '0';
                        overlay.style.transition = 'opacity 0.5s ease';
                        setTimeout(() => {
                            if (document.body.contains(overlay)) {
                                document.body.removeChild(overlay);
                            }
                            resolve();
                        }, 500);
                    }, 4500);
                });
            }

            // Enhanced dice animation for received events
            playDiceAnimationForPlayer(playerAddress, roll) {
                const player = this.players.find(p => p.address === playerAddress);
                if (!player) return;

                // Show a notification banner for other players' rolls
                this.showDiceRollNotification(player.name, roll);

                // Create floating dice animation above the player
                const gameBoard = document.getElementById('gameBoard');
                const playerElement = document.querySelector(`[data-player="${playerAddress}"]`);
                
                if (playerElement && gameBoard) {
                    const rect = playerElement.getBoundingClientRect();
                    const boardRect = gameBoard.getBoundingClientRect();
                    
                    const diceFloat = document.createElement('div');
                    diceFloat.style.cssText = `
                        position: absolute;
                        left: ${rect.left - boardRect.left + 20}px;
                        top: ${rect.top - boardRect.top - 80}px;
                        width: 60px;
                        height: 60px;
                        background: linear-gradient(145deg, #fff, #f0f0f0);
                        border: 3px solid #333;
                        border-radius: 12px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-weight: bold;
                        font-size: 24px;
                        z-index: 1000;
                        animation: diceFloat 3s ease-out forwards;
                        box-shadow: 0 8px 25px rgba(0,0,0,0.4);
                        text-shadow: 0 1px 2px rgba(0,0,0,0.3);
                    `;
                    diceFloat.textContent = roll;

                    gameBoard.appendChild(diceFloat);

                    // Add floating animation if not exists
                    if (!document.querySelector('#dice-float-styles')) {
                        const style = document.createElement('style');
                        style.id = 'dice-float-styles';
                        style.textContent = `
                            @keyframes diceFloat {
                                0% { 
                                    transform: translateY(0) scale(0.3) rotate(0deg); 
                                    opacity: 0; 
                                }
                                20% { 
                                    transform: translateY(-20px) scale(1) rotate(180deg); 
                                    opacity: 1; 
                                }
                                80% { 
                                    transform: translateY(-40px) scale(1.1) rotate(340deg); 
                                    opacity: 1; 
                                }
                                100% { 
                                    transform: translateY(-80px) scale(0.6) rotate(360deg); 
                                    opacity: 0; 
                                }
                            }
                        `;
                        document.head.appendChild(style);
                    }

                    // Remove after animation
                    setTimeout(() => {
                        if (gameBoard.contains(diceFloat)) {
                            gameBoard.removeChild(diceFloat);
                        }
                    }, 3000);
                }

                // Also show notification
                this.logToTerminal(`üé≤ ${player.name} rolled ${roll}!`);
            }

            // Animate main dice when other players roll
            animateMainDiceForOtherPlayer(roll, playerName) {
                const dice = document.getElementById('dice3D');
                const lastRollInfo = document.getElementById('lastRollInfo');
                
                if (dice && lastRollInfo) {
                    // Add animation and show the roll
                    dice.classList.add('dice-rolling');
                    lastRollInfo.textContent = `${playerName} rolled ${roll}!`;
                    lastRollInfo.style.color = '#4CAF50';
                    lastRollInfo.style.fontWeight = 'bold';
                    
                    // Update dice faces to show the rolled number
                    setTimeout(() => {
                        this.updateDiceFaces(roll);
                        dice.classList.remove('dice-rolling');
                        
                        // Reset info after a moment
                        setTimeout(() => {
                            lastRollInfo.style.color = '';
                            lastRollInfo.style.fontWeight = '';
                            if (!this.gameStarted || this.players[this.currentPlayerIndex]?.isYou) {
                                lastRollInfo.textContent = this.lastRoll ? `Last roll: ${this.lastRoll}` : 'Ready to roll';
                            }
                        }, 2000);
                    }, 1500);
                }
            }

            // Update dice faces to show specific number
            updateDiceFaces(number) {
                const faces = ['‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ'];
                const dice = document.getElementById('dice3D');
                
                if (dice) {
                    const diceFaces = dice.querySelectorAll('.dice-face');
                    diceFaces.forEach((face, index) => {
                        if (index === 0) { // front face
                            face.textContent = faces[number - 1];
                        }
                    });
                }
            }

            // Show dice roll notification banner
            showDiceRollNotification(playerName, roll) {
                // üéµ Play notification sound
                this.sounds.notification?.();
                
                // Create notification banner
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: linear-gradient(135deg, #4CAF50, #45a049);
                    color: white;
                    padding: 15px 30px;
                    border-radius: 25px;
                    font-size: 20px;
                    font-weight: bold;
                    z-index: 10001;
                    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                    animation: slideInNotification 0.5s ease-out;
                    border: 2px solid #fff;
                `;
                notification.innerHTML = `
                    üé≤ <span style="color: #ffeb3b;">${playerName}</span> rolled <span style="font-size: 24px; color: #ffeb3b;">${roll}</span>!
                `;

                // Add slide animation
                if (!document.querySelector('#notification-styles')) {
                    const style = document.createElement('style');
                    style.id = 'notification-styles';
                    style.textContent = `
                        @keyframes slideInNotification {
                            from { 
                                opacity: 0; 
                                transform: translateX(-50%) translateY(-30px); 
                            }
                            to { 
                                opacity: 1; 
                                transform: translateX(-50%) translateY(0); 
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }

                document.body.appendChild(notification);

                // Remove notification after 3 seconds
                setTimeout(() => {
                    notification.style.opacity = '0';
                    notification.style.transform = 'translateX(-50%) translateY(-30px)';
                    notification.style.transition = 'all 0.5s ease';
                    setTimeout(() => {
                        if (document.body.contains(notification)) {
                            document.body.removeChild(notification);
                        }
                    }, 500);
                }, 3000);
            }

            async rollDice() {
                if (!this.gameStarted) {
                    alert('‚ö†Ô∏è Game has not started yet!');
                    return;
                }

                const currentPlayer = this.players[this.currentPlayerIndex];
                if (!currentPlayer.isYou && !currentPlayer.isBot) {
                    alert('‚ö†Ô∏è It\'s not your turn!');
                    return;
                }

                // For human players, check if blockchain mode is enabled
                if (currentPlayer.isYou) {
                    const useBlockchain = document.getElementById('blockchainModeToggle').checked;
                    if (useBlockchain) {
                        await this.blockchainDiceRoll(currentPlayer);
                    } else {
                        await this.localDiceRoll(currentPlayer);
                    }
                } else if (currentPlayer.isBot) {
                    // AI players use simulated roll
                    this.simulatedDiceRoll(currentPlayer);
                }
            }

            async blockchainDiceRoll(player) {
                try {
                    this.logToTerminal(`üé≤ ${player.name} initiating blockchain dice roll...`);
                    this.logToTerminal('üí≥ Cost: 0.0001 MON + gas fees (~0.008 MON)');
                    
                    // Check network status first
                    try {
                        const networkVersion = await window.ethereum.request({ method: 'net_version' });
                        const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                        this.logToTerminal(`üåê Network check: Chain ${chainId} (Version ${networkVersion})`);
                        
                        if (chainId !== '0x279F') {
                            this.logToTerminal('‚ö†Ô∏è Wrong network detected - switching to Monad Testnet');
                            await this.switchToMonadTestnet();
                        }
                    } catch (networkError) {
                        this.logToTerminal('‚ö†Ô∏è Network check failed - proceeding with transaction');
                    }
                    
                    // Start dice animation
                    const dice = document.getElementById('dice3D');
                    const rollBtn = document.getElementById('rollDiceBtn');
                    const lastRollInfo = document.getElementById('lastRollInfo');
                    
                    dice.classList.add('dice-rolling');
                    rollBtn.disabled = true;
                    rollBtn.textContent = 'PROCESSING...';
                    lastRollInfo.textContent = 'Blockchain transaction pending...';

                    // Create transaction with current network gas settings
                    const rollTx = {
                        to: this.contractAddress,
                        from: this.playerAddress,
                        value: '0x5AF3107A4000', // 0.0001 MON in wei
                        data: '0x1e14dcc4', // rollDice() function selector
                        gas: '0x15F90', // 90,000 gas limit (reduced for safety)
                        gasPrice: '0x12A05F200' // 80 Gwei (reduced gas price)
                    };
                    
                    const txHash = await window.ethereum.request({
                        method: 'eth_sendTransaction',
                        params: [rollTx]
                    });
                    
                    this.logToTerminal(`üìù Dice roll transaction: ${txHash.substring(0, 20)}...`);
                    this.logToTerminal('‚è≥ Waiting for blockchain confirmation...');
                    
                    // Get deterministic dice roll from Multisynq service
                    try {
                        const response = await fetch('http://localhost:3001/dice-roll', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                playerId: this.playerAddress,
                                gameId: this.roomId,
                                transactionHash: txHash,
                                timestamp: Date.now()
                            })
                        });
                        
                        const rollData = await response.json();
                        
                        if (rollData.success) {
                            this.logToTerminal(`üéØ Multisynq deterministic roll: ${rollData.roll}`);
                            
                            // Wait for transaction confirmation
                            this.waitForTransaction(txHash).then(() => {
                                this.processDiceResult(player, rollData.roll, txHash);
                                
                                dice.classList.remove('dice-rolling');
                                rollBtn.disabled = false;
                                rollBtn.textContent = 'ROLL DICE';
                            }).catch((error) => {
                                this.logToTerminal(`‚ùå Transaction failed: ${error.message}`);
                                // Still use the deterministic roll
                                this.processDiceResult(player, rollData.roll, null);
                                
                                dice.classList.remove('dice-rolling');
                                rollBtn.disabled = false;
                                rollBtn.textContent = 'ROLL DICE';
                            });
                        } else {
                            throw new Error('Multisynq service failed');
                        }
                    } catch (serviceError) {
                        this.logToTerminal('‚ö†Ô∏è Multisynq service unavailable, using local roll');
                        const roll = Math.floor(Math.random() * 6) + 1;
                        
                        this.waitForTransaction(txHash).then(() => {
                            this.processDiceResult(player, roll, txHash);
                            
                            dice.classList.remove('dice-rolling');
                            rollBtn.disabled = false;
                            rollBtn.textContent = 'ROLL DICE';
                        }).catch((error) => {
                            this.logToTerminal(`‚ùå Transaction failed: ${error.message}`);
                            this.processDiceResult(player, roll, null);
                            
                            dice.classList.remove('dice-rolling');
                            rollBtn.disabled = false;
                            rollBtn.textContent = 'ROLL DICE';
                        });
                    }
                    
                } catch (error) {
                    console.error('Blockchain dice roll failed:', error);
                    this.logToTerminal(`‚ùå Blockchain roll failed: ${error.message}`);
                    
                    // Check if it's a specific error type
                    if (error.message.includes('JSON-RPC') || error.message.includes('Internal')) {
                        this.logToTerminal('üîß Network issue detected - using secure local roll');
                    } else if (error.code === 4001) {
                        this.logToTerminal('‚ùå Transaction rejected by user');
                        const dice = document.getElementById('dice3D');
                        const rollBtn = document.getElementById('rollDiceBtn');
                        dice.classList.remove('dice-rolling');
                        rollBtn.disabled = false;
                        rollBtn.textContent = 'ROLL DICE';
                        return; // Don't roll if user rejected
                    } else {
                        this.logToTerminal('üéÆ Switching to local dice roll...');
                    }
                    
                    // Immediate fallback to local roll with animation
                    const roll = Math.floor(Math.random() * 6) + 1;
                    this.logToTerminal(`üé≤ Local roll generated: ${roll}`);
                    
                    // Clean up UI
                    const dice = document.getElementById('dice3D');
                    const rollBtn = document.getElementById('rollDiceBtn');
                    dice.classList.remove('dice-rolling');
                    rollBtn.disabled = false;
                    rollBtn.textContent = 'ROLL DICE';
                    
                    // Process the result immediately
                    this.processDiceResult(player, roll, null);
                }
            }

            async localDiceRoll(player) {
                this.logToTerminal(`üé≤ ${player.name} rolling local dice (FREE)...`);
                
                // Start dice animation
                const dice = document.getElementById('dice3D');
                const rollBtn = document.getElementById('rollDiceBtn');
                const lastRollInfo = document.getElementById('lastRollInfo');
                
                dice.classList.add('dice-rolling');
                rollBtn.disabled = true;
                rollBtn.textContent = 'ROLLING...';
                lastRollInfo.textContent = 'Rolling dice...';
                
                // Generate random roll
                const roll = Math.floor(Math.random() * 6) + 1;
                this.logToTerminal(`üéØ Local roll generated: ${roll}`);
                
                // Add to dice history immediately
                this.addDiceRoll(player, roll, player.position);
                
                // Wait for animation then process result
                setTimeout(() => {
                    dice.classList.remove('dice-rolling');
                    rollBtn.disabled = false;
                    rollBtn.textContent = 'ROLL DICE';
                    
                    // Process the result with full-screen animation
                    this.processDiceResult(player, roll, null);
                }, 1500);
            }

            simulatedDiceRoll(player) {
                this.logToTerminal(`ü§ñ ${player.name} rolling dice...`);
                
                const dice = document.getElementById('dice3D');
                const rollBtn = document.getElementById('rollDiceBtn');
                const lastRollInfo = document.getElementById('lastRollInfo');
                
                dice.classList.add('dice-rolling');
                rollBtn.disabled = true;
                rollBtn.textContent = 'AI ROLLING...';
                lastRollInfo.textContent = 'AI rolling...';
                
                setTimeout(() => {
                    const roll = Math.floor(Math.random() * 6) + 1;
                    this.processDiceResult(player, roll, null);
                    
                    dice.classList.remove('dice-rolling');
                    rollBtn.disabled = false;
                    rollBtn.textContent = 'ROLL DICE';
                }, 1500);
            }

            async processDiceResult(player, roll, txHash) {
                this.lastRoll = roll;
                
                // üìä Update dice roll stats
                if (player.isYou) {
                    this.playerStats.totalDiceRolls++;
                }
                
                // üéµ Play dice roll sound
                this.sounds.diceRoll?.();
                
                // üé™ Trigger screen shake for dramatic effect
                this.triggerScreenShake(5);
                
                // Show full-screen dice animation for current player
                if (player.isYou) {
                    await this.showFullScreenDiceAnimation(roll, !!txHash);
                }
                
                if (txHash) {
                    this.logToTerminal(`‚úÖ Blockchain confirmed! ${player.name} rolled ${roll}! (0.0001 MON + gas)`);
                    this.logToTerminal(`üîó Transaction: ${txHash.substring(0, 20)}...`);
                    
                    // Submit the result to smart contract
                    try {
                        if (this.contract) {
                            await this.contract.call('submitDiceRoll', [roll]);
                            this.logToTerminal('üìù Result submitted to blockchain');
                        }
                    } catch (error) {
                        console.error('Submit result failed:', error);
                    }
                } else {
                    this.logToTerminal(`üé≤ ${player.name} rolled ${roll}!`);
                }
                
                // Move the player
                this.movePlayer(player, roll);
                
                // Broadcast the roll to other players
                if (player.isYou && this.backendConnected) {
                    try {
                        await fetch('http://localhost:3001/broadcast-dice', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                roomCode: this.roomId,
                                playerAddress: player.address,
                                playerName: player.name,
                                roll: roll,
                                position: this.playerPositions[player.address],
                                blockchain: !!txHash,
                                txHash: txHash,
                                timestamp: Date.now(),
                                showAnimation: true  // Flag for animation
                            })
                        });
                        this.logToTerminal('üì° Dice roll broadcasted to other players');
                        // Don't call nextTurn() locally - let backend manage turns
                    } catch (error) {
                        this.logToTerminal('‚ö†Ô∏è Failed to broadcast dice roll');
                        // Fallback to local turn management if backend fails
                        this.nextTurn();
                    }
                } else {
                    // For non-multiplayer or non-backend modes, use local turn management
                    this.nextTurn();
                }
                
                // Legacy Multisynq broadcast (if available)
                if (this.multisynqClient && player.isYou) {
                    try {
                        this.multisynqClient.emit('gameEvent', {
                            type: 'diceRolled',
                            playerName: player.name,
                            playerAddress: player.address,
                            roll: roll,
                            round: this.currentRound,
                            blockchain: !!txHash,
                            txHash: txHash,
                            roomId: this.roomId
                        });
                    } catch (error) {
                        console.log('Broadcast failed:', error);
                    }
                }
            }

            movePlayer(player, roll) {
                const currentPos = this.playerPositions[player.address] || 1;
                let newPos = currentPos + roll;
                
                if (newPos > 100) {
                    newPos = currentPos;
                    this.logToTerminal(`${player.name} can't move - would exceed 100!`);
                } else {
                    // üé™ Animate player movement
                    this.smoothMovePlayerToPosition(player.address, currentPos, currentPos + roll);
                    
                    // Check for ladders
                    if (this.LADDERS[newPos]) {
                        const ladderEnd = this.LADDERS[newPos];
                        this.logToTerminal(`ü™ú ${player.name} climbed ladder ${newPos}‚Üí${ladderEnd}!`);
                        
                        // üéµ Play ladder sound
                        this.sounds.ladderClimb?.();
                        
                        // üé™ Create particle effect and screen shake
                        setTimeout(() => {
                            const cell = document.getElementById(`modern-cell-${ladderEnd}`);
                            if (cell) {
                                const rect = cell.getBoundingClientRect();
                                const boardRect = document.getElementById('gameBoardModern').getBoundingClientRect();
                                this.createParticleExplosion(
                                    rect.left - boardRect.left + rect.width / 2,
                                    rect.top - boardRect.top + rect.height / 2,
                                    '#ffaa00', 15
                                );
                            }
                            this.triggerScreenShake(8);
                            
                            // üìä Update stats
                            this.playerStats.laddersClimbed++;
                            this.savePlayerStats();
                        }, 400);
                        
                        newPos = ladderEnd;
                    }
                    // Check for snakes
                    else if (this.SNAKES[newPos]) {
                        const snakeEnd = this.SNAKES[newPos];
                        this.logToTerminal(`üêç ${player.name} slid down snake ${newPos}‚Üí${snakeEnd}!`);
                        
                        // üéµ Play snake sound
                        this.sounds.snakeSlide?.();
                        
                        // üé™ Create particle effect and screen shake
                        setTimeout(() => {
                            const cell = document.getElementById(`modern-cell-${snakeEnd}`);
                            if (cell) {
                                const rect = cell.getBoundingClientRect();
                                const boardRect = document.getElementById('gameBoardModern').getBoundingClientRect();
                                this.createParticleExplosion(
                                    rect.left - boardRect.left + rect.width / 2,
                                    rect.top - boardRect.top + rect.height / 2,
                                    '#ff4444', 20
                                );
                            }
                            this.triggerScreenShake(12);
                            
                            // üìä Update stats
                            this.playerStats.snakesHit++;
                            this.savePlayerStats();
                        }, 400);
                        
                        newPos = snakeEnd;
                    }
                    
                    this.logToTerminal(`üèÉ ${player.name} moved to position ${newPos}`);
                }
                
                this.playerPositions[player.address] = newPos;
                
                // Check for victory
                if (newPos === 100) {
                    this.logToTerminal(`üèÜ ${player.name} WINS THE GAME! üéâ`);
                    this.gameStarted = false;
                    
                    // üìä Update stats
                    if (player.isYou) {
                        this.playerStats.gamesWon++;
                    }
                    this.playerStats.gamesPlayed++;
                    this.playerStats.totalDiceRolls++;
                    this.savePlayerStats(); // Save stats to localStorage
                    
                    this.celebrateVictory(player);
                }
                
                this.updateAllUI();
            }

            celebrateVictory(winner) {
                // üéµ Play victory fanfare
                this.sounds.victory?.();
                
                // üé™ Epic celebration effects
                const board = document.getElementById('gameBoardModern');
                board.style.animation = 'finishGlow 0.5s ease-in-out 6';
                
                // üé™ Massive screen shake and particle explosion
                this.triggerScreenShake(25);
                
                // Create multiple particle explosions
                const boardRect = board.getBoundingClientRect();
                const centerX = boardRect.width / 2;
                const centerY = boardRect.height / 2;
                
                setTimeout(() => this.createParticleExplosion(centerX, centerY, '#ffff00', 30), 0);
                setTimeout(() => this.createParticleExplosion(centerX - 100, centerY - 50, '#ff00ff', 25), 200);
                setTimeout(() => this.createParticleExplosion(centerX + 100, centerY + 50, '#00ffff', 25), 400);
                setTimeout(() => this.createParticleExplosion(centerX, centerY - 100, '#ff4444', 20), 600);
                setTimeout(() => this.createParticleExplosion(centerX + 50, centerY + 100, '#44ff44', 20), 800);
                
                // Victory message with enhanced styling
                setTimeout(() => {
                    // Create custom victory modal instead of alert
                    this.showVictoryModal(winner);
                    board.style.animation = '';
                }, 2000);
            }

            showVictoryModal(winner) {
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    background: rgba(0, 0, 0, 0.9);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                    backdrop-filter: blur(10px);
                `;
                
                modal.innerHTML = `
                    <div style="
                        background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
                        border: 3px solid #ffff00;
                        border-radius: 20px;
                        padding: 40px;
                        text-align: center;
                        box-shadow: 0 0 50px rgba(255, 255, 0, 0.5);
                        animation: victoryPulse 2s ease-in-out infinite;
                    ">
                        <h1 style="
                            font-size: 48px;
                            color: #ffff00;
                            margin: 0 0 20px 0;
                            text-shadow: 0 0 30px rgba(255, 255, 0, 0.8);
                            animation: victoryGlow 1s ease-in-out infinite alternate;
                        ">üèÜ VICTORY! üèÜ</h1>
                        
                        <h2 style="
                            font-size: 32px;
                            color: #fff;
                            margin: 20px 0;
                            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
                        ">${winner.name} WINS!</h2>
                        
                        <div style="
                            font-size: 18px;
                            color: #aaa;
                            margin: 20px 0;
                        ">
                            üéä Congratulations! üéä<br>
                            Games Played: ${this.playerStats.gamesPlayed}<br>
                            ${winner.isYou ? `Your Wins: ${this.playerStats.gamesWon}` : ''}
                        </div>
                        
                        <button onclick="this.parentElement.parentElement.remove()" style="
                            background: linear-gradient(135deg, #00ff88, #00cc66);
                            border: none;
                            color: white;
                            padding: 15px 30px;
                            font-size: 18px;
                            border-radius: 25px;
                            cursor: pointer;
                            margin-top: 20px;
                            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.3);
                            transition: transform 0.2s;
                        " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                            üöÄ PLAY AGAIN
                        </button>
                    </div>
                `;
                
                // Add victory animations to head if not exists
                if (!document.querySelector('#victory-styles')) {
                    const style = document.createElement('style');
                    style.id = 'victory-styles';
                    style.textContent = `
                        @keyframes victoryPulse {
                            0%, 100% { transform: scale(1); }
                            50% { transform: scale(1.05); }
                        }
                        @keyframes victoryGlow {
                            from { text-shadow: 0 0 30px rgba(255, 255, 0, 0.8); }
                            to { text-shadow: 0 0 50px rgba(255, 255, 0, 1), 0 0 80px rgba(255, 255, 0, 0.6); }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                document.body.appendChild(modal);
            }

            nextTurn() {
                if (!this.gameStarted) return;
                
                this.currentPlayerIndex = (this.currentPlayerIndex + 1) % this.players.length;
                
                if (this.currentPlayerIndex === 0) {
                    this.currentRound++;
                }
                
                const nextPlayer = this.players[this.currentPlayerIndex];
                this.logToTerminal(`üëâ ${nextPlayer.name}'s turn (Round ${this.currentRound})`);
                this.updateAllUI();
                
                // Auto-roll for AI
                if (nextPlayer.isBot) {
                    setTimeout(() => this.rollDice(), 1500);
                }
            }

            createModernBoard() {
                const board = document.getElementById('gameBoardModern');
                board.innerHTML = '';
                board.style.position = 'relative';
                
                // Create squares 100 to 1 (reverse order)
                for (let i = 100; i >= 1; i--) {
                    const cell = document.createElement('div');
                    cell.className = 'board-cell-modern';
                    cell.id = `modern-cell-${i}`;
                    cell.textContent = i;
                    
                    if (i === 100) {
                        cell.classList.add('finish');
                        cell.innerHTML = `${i}<br>üèÜ`;
                    } else if (this.SNAKES[i]) {
                        cell.classList.add('snake');
                        cell.innerHTML = `${i}<br>üêç`;
                        cell.title = `üêç Snake! Slide to ${this.SNAKES[i]}`;
                    } else if (this.LADDERS[i]) {
                        cell.classList.add('ladder');
                        cell.innerHTML = `${i}<br>ü™ú`;
                        cell.title = `ü™ú Ladder! Climb to ${this.LADDERS[i]}`;
                    }
                    
                    board.appendChild(cell);
                }
                
                // Add visual snakes and ladders after board is created
                setTimeout(() => {
                    this.addSnakesAndLadders();
                }, 100);
            }

            addSnakesAndLadders() {
                const board = document.getElementById('gameBoardModern');
                
                // Add CSS for snakes and ladders if not exists
                if (!document.querySelector('#snakes-ladders-styles')) {
                    const style = document.createElement('style');
                    style.id = 'snakes-ladders-styles';
                    style.textContent = `
                        .visual-snake {
                            position: absolute;
                            z-index: 5;
                            pointer-events: none;
                        }
                        
                        .visual-ladder {
                            position: absolute;
                            z-index: 5;
                            pointer-events: none;
                        }
                        
                        .snake-body {
                            background: linear-gradient(90deg, #00ff88, #00ccaa, #0099cc, #00ff88);
                            border-radius: 12px;
                            box-shadow: 
                                0 0 20px rgba(0, 255, 136, 0.8),
                                inset 0 0 10px rgba(255, 255, 255, 0.2);
                            animation: snakeGlow 2s ease-in-out infinite alternate;
                            border: 2px solid rgba(0, 255, 136, 0.5);
                        }
                        
                        .snake-head {
                            width: 24px;
                            height: 24px;
                            background: radial-gradient(circle, #ff4444, #cc2222, #aa1111);
                            border-radius: 50%;
                            position: absolute;
                            box-shadow: 
                                0 0 15px rgba(255, 68, 68, 1),
                                inset 0 0 8px rgba(255, 255, 255, 0.3);
                            border: 2px solid #ff6666;
                        }
                        
                        .snake-head::before {
                            content: '';
                            position: absolute;
                            width: 4px;
                            height: 4px;
                            background: #fff;
                            border-radius: 50%;
                            top: 6px;
                            left: 8px;
                            box-shadow: 4px 0 0 #fff;
                        }
                        
                        .ladder-rail {
                            background: linear-gradient(180deg, #ffaa00, #ff8800, #ffaa00);
                            box-shadow: 
                                0 0 15px rgba(255, 170, 0, 0.8),
                                inset 0 0 5px rgba(255, 255, 255, 0.3);
                            animation: ladderGlow 2s ease-in-out infinite alternate;
                            border: 1px solid rgba(255, 170, 0, 0.6);
                        }
                        
                        .ladder-rung {
                            background: linear-gradient(90deg, #ffcc44, #ffaa22, #ffcc44);
                            box-shadow: 
                                0 0 10px rgba(255, 204, 68, 0.7),
                                inset 0 0 3px rgba(255, 255, 255, 0.4);
                            border: 1px solid rgba(255, 204, 68, 0.5);
                        }
                        
                        @keyframes snakeGlow {
                            from { 
                                box-shadow: 
                                    0 0 20px rgba(0, 255, 136, 0.6),
                                    inset 0 0 10px rgba(255, 255, 255, 0.2);
                            }
                            to { 
                                box-shadow: 
                                    0 0 35px rgba(0, 255, 136, 1),
                                    inset 0 0 15px rgba(255, 255, 255, 0.3);
                            }
                        }
                        
                        @keyframes ladderGlow {
                            from { 
                                box-shadow: 
                                    0 0 15px rgba(255, 170, 0, 0.6),
                                    inset 0 0 5px rgba(255, 255, 255, 0.3);
                            }
                            to { 
                                box-shadow: 
                                    0 0 25px rgba(255, 170, 0, 1),
                                    inset 0 0 8px rgba(255, 255, 255, 0.4);
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                // Draw snakes
                Object.entries(this.SNAKES).forEach(([start, end]) => {
                    this.drawSnake(parseInt(start), parseInt(end));
                });
                
                // Draw ladders
                Object.entries(this.LADDERS).forEach(([start, end]) => {
                    this.drawLadder(parseInt(start), parseInt(end));
                });
            }

            getCellPosition(cellNumber) {
                const cell = document.getElementById(`modern-cell-${cellNumber}`);
                if (!cell) return null;
                
                const board = document.getElementById('gameBoardModern');
                const boardRect = board.getBoundingClientRect();
                const cellRect = cell.getBoundingClientRect();
                
                return {
                    x: cellRect.left - boardRect.left + cellRect.width / 2,
                    y: cellRect.top - boardRect.top + cellRect.height / 2,
                    width: cellRect.width,
                    height: cellRect.height
                };
            }

            drawSnake(start, end) {
                const startPos = this.getCellPosition(start);
                const endPos = this.getCellPosition(end);
                
                if (!startPos || !endPos) return;
                
                const board = document.getElementById('gameBoardModern');
                
                // Calculate snake path
                const deltaX = endPos.x - startPos.x;
                const deltaY = endPos.y - startPos.y;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
                
                // Create snake body
                const snake = document.createElement('div');
                snake.className = 'visual-snake';
                snake.innerHTML = `
                    <div class="snake-body" style="
                        width: ${distance}px;
                        height: 12px;
                        transform: rotate(${angle}deg);
                        transform-origin: 0 50%;
                        position: relative;
                    ">
                        <div class="snake-head" style="
                            right: -10px;
                            top: -4px;
                        "></div>
                    </div>
                `;
                
                snake.style.left = `${startPos.x}px`;
                snake.style.top = `${startPos.y - 6}px`;
                snake.title = `üêç Snake ${start}‚Üí${end}`;
                
                board.appendChild(snake);
            }

            drawLadder(start, end) {
                const startPos = this.getCellPosition(start);
                const endPos = this.getCellPosition(end);
                
                if (!startPos || !endPos) return;
                
                const board = document.getElementById('gameBoardModern');
                
                // Calculate ladder dimensions
                const deltaX = endPos.x - startPos.x;
                const deltaY = endPos.y - startPos.y;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
                
                // Create ladder
                const ladder = document.createElement('div');
                ladder.className = 'visual-ladder';
                
                // Create ladder structure
                const rungs = Math.floor(distance / 20);
                let ladderHTML = `
                    <div style="
                        width: ${distance}px;
                        height: 16px;
                        transform: rotate(${angle}deg);
                        transform-origin: 0 50%;
                        position: relative;
                    ">
                        <div class="ladder-rail" style="
                            width: 100%;
                            height: 3px;
                            position: absolute;
                            top: 2px;
                        "></div>
                        <div class="ladder-rail" style="
                            width: 100%;
                            height: 3px;
                            position: absolute;
                            bottom: 2px;
                        "></div>
                `;
                
                // Add rungs
                for (let i = 1; i < rungs; i++) {
                    const rungPos = (i / rungs) * 100;
                    ladderHTML += `
                        <div class="ladder-rung" style="
                            width: 2px;
                            height: 12px;
                            position: absolute;
                            left: ${rungPos}%;
                            top: 2px;
                        "></div>
                    `;
                }
                
                ladderHTML += '</div>';
                ladder.innerHTML = ladderHTML;
                
                ladder.style.left = `${startPos.x}px`;
                ladder.style.top = `${startPos.y - 8}px`;
                ladder.title = `ü™ú Ladder ${start}‚Üí${end}`;
                
                board.appendChild(ladder);
            }

            updateAllUI() {
                this.updatePlayersDisplay();
                this.updatePlayerPositions();
                this.updateGameControls();
                this.updateCurrentPlayerDisplay();
                this.updateStats();
                this.updateLastRollInfo();
            }

            updatePlayersDisplay() {
                const container = document.getElementById('playersContainer');
                
                if (this.players.length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; color: var(--text-secondary); padding: 1rem 0;">
                            No players connected
                        </div>
                    `;
                    return;
                }

                container.innerHTML = '';
                this.players.forEach((player, index) => {
                    const card = document.createElement('div');
                    card.className = 'player-card';
                    
                    if (index === this.currentPlayerIndex && this.gameStarted) {
                        card.classList.add('current');
                    }

                    const position = this.playerPositions[player.address] || 1;
                    const youLabel = player.isYou ? ' (YOU)' : '';
                    const hostLabel = (player.isYou && this.isHost) ? ' üëë' : '';
                    
                    card.innerHTML = `
                        <div style="display: flex; align-items: center;">
                            <div class="player-avatar player-${index + 1}">${index + 1}</div>
                            <div style="flex: 1;">
                                <div style="font-weight: 600; margin-bottom: 0.25rem;">
                                    ${player.name}${youLabel}${hostLabel}
                                </div>
                                <div style="font-size: 0.75rem; color: var(--text-secondary);">
                                    ${this.shortAddress(player.address)}
                                </div>
                                <div style="font-size: 0.875rem; margin-top: 0.25rem;">
                                    Position: <span style="color: var(--accent-purple); font-weight: 600;">${position}</span>
                                </div>
                            </div>
                        </div>
                        ${index === this.currentPlayerIndex && this.gameStarted ? 
                            '<div style="color: var(--accent-orange); text-align: center; margin-top: 0.5rem; font-weight: 600;">‚ö° ACTIVE TURN</div>' : ''}
                    `;
                    container.appendChild(card);
                });
            }

            updatePlayerPositions() {
                // Clear existing player markers
                document.querySelectorAll('.board-cell-modern .player-avatar').forEach(avatar => avatar.remove());

                // Add player markers to current positions
                this.players.forEach((player, index) => {
                    const position = this.playerPositions[player.address] || 1;
                    const cell = document.getElementById(`modern-cell-${position}`);
                    if (cell) {
                        const avatar = document.createElement('div');
                        avatar.className = `player-avatar player-${index + 1}`;
                        avatar.dataset.player = player.address;
                        
                        // Use custom avatar or default
                        avatar.textContent = player.avatar || this.playerAvatars[index] || (index + 1).toString();
                        
                        avatar.style.cssText = `
                            position: absolute;
                            width: 20px;
                            height: 20px;
                            font-size: 14px;
                            top: 2px;
                            left: ${2 + (index * 16)}px;
                            z-index: 10;
                            background: rgba(0, 0, 0, 0.8);
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            border: 2px solid ${this.getPlayerColor(index)};
                            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
                            transition: all 0.3s ease;
                        `;
                        
                        avatar.title = `${player.name} - Position ${position}`;
                        cell.style.position = 'relative';
                        cell.appendChild(avatar);
                    }
                });
            }

            getPlayerColor(index) {
                const colors = ['#8b5cf6', '#06b6d4', '#10b981', '#f59e0b', '#ef4444', '#ec4899'];
                return colors[index % colors.length];
            }

            updateGameControls() {
                const joinBtn = document.getElementById('joinGameBtn');
                const startBtn = document.getElementById('startGameBtn');
                const rollBtn = document.getElementById('rollDiceBtn');

                const hasJoined = this.players.find(p => p.address === this.playerAddress);
                
                joinBtn.disabled = !this.playerAddress || this.gameStarted || hasJoined;
                startBtn.disabled = this.gameStarted || this.players.length < 2 || !hasJoined;
                
                const currentPlayer = this.players[this.currentPlayerIndex];
                rollBtn.disabled = !this.gameStarted || (currentPlayer && !currentPlayer.isYou);
                
                // Update button text
                if (hasJoined) {
                    joinBtn.textContent = '‚úÖ JOINED';
                    joinBtn.classList.add('success');
                }
                
                if (this.gameStarted) {
                    startBtn.textContent = '‚úÖ GAME ACTIVE';
                    startBtn.classList.add('success');
                } else if (this.players.length < 2) {
                    startBtn.textContent = 'NEED MORE PLAYERS';
                } else if (!hasJoined) {
                    startBtn.textContent = 'JOIN FIRST';
                } else {
                    startBtn.textContent = 'START GAME';
                }
            }

            updateCurrentPlayerDisplay() {
                const display = document.getElementById('currentPlayerDisplay');
                
                if (!this.gameStarted && this.players.length === 0) {
                    display.textContent = 'Waiting for players to connect...';
                } else if (!this.gameStarted && this.players.length < 2) {
                    display.textContent = `${this.players.length}/2 players connected`;
                } else if (!this.gameStarted && this.players.length >= 2) {
                    display.textContent = 'Ready to start the game!';
                } else if (this.gameStarted) {
                    const currentPlayer = this.players[this.currentPlayerIndex];
                    display.innerHTML = `üéØ <span style="color: var(--accent-purple);">${currentPlayer.name}</span>'s turn`;
                }
            }

            updateStats() {
                document.getElementById('totalGames').textContent = this.totalGames;
                document.getElementById('currentRound').textContent = this.currentRound;
            }

            updateLastRollInfo() {
                const lastRollInfo = document.getElementById('lastRollInfo');
                if (this.lastRoll) {
                    lastRollInfo.textContent = `Last roll: ${this.lastRoll}`;
                    
                    // Update dice faces
                    const faces = ['‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ'];
                    document.querySelector('.dice-face.front').textContent = faces[this.lastRoll - 1];
                } else {
                    lastRollInfo.textContent = 'Ready to roll';
                }
            }

            updateWalletUI(balance) {
                document.getElementById('walletDot').className = 'status-dot online';
                document.getElementById('walletStatusText').textContent = 'Wallet Connected';
                document.getElementById('walletDisplay').textContent = 
                    `${this.shortAddress(this.playerAddress)} | ${balance.toFixed(4)} MON`;
                document.getElementById('connectWalletBtn').textContent = '‚úÖ CONNECTED';
                document.getElementById('connectWalletBtn').disabled = true;
                document.getElementById('connectWalletBtn').classList.add('success');
            }

            updateMultisynqStatus(status) {
                const dot = document.getElementById('multisynqDot');
                const text = document.getElementById('multisynqStatusText');
                
                switch (status) {
                    case 'online':
                        dot.className = 'status-dot online';
                        text.textContent = 'Multisynq Connected';
                        break;
                    case 'offline':
                        dot.className = 'status-dot offline';
                        text.textContent = 'Demo Mode';
                        break;
                    case 'connecting':
                        dot.className = 'status-dot offline';
                        text.textContent = 'Connecting...';
                        break;
                }
            }

            logToTerminal(message) {
                const terminal = document.getElementById('gameTerminal');
                const line = document.createElement('div');
                line.className = 'terminal-line';
                line.innerHTML = `<span style="color: var(--text-secondary);">${new Date().toLocaleTimeString()}</span> ${message}`;
                terminal.appendChild(line);
                terminal.scrollTop = terminal.scrollHeight;
                
                // Keep only last 50 lines
                while (terminal.children.length > 50) {
                    terminal.removeChild(terminal.firstChild);
                }
            }

            shortAddress(address) {
                return `${address.substring(0, 6)}...${address.substring(38)}`;
            }
        }

        // üåç GLOBAL MODAL FUNCTION - Available immediately
        window.addClickOutsideToModal = function(modalId) {
            setTimeout(() => {
                const modal = document.getElementById(modalId);
                if (modal) {
                    console.log(`üéØ Setting up click-outside for ${modalId}`, modal);
                    modal.onclick = function(event) {
                        console.log(`üñ±Ô∏è Modal overlay clicked:`, event.target, 'vs modal:', modal);
                        if (event.target === modal) {
                            console.log(`üö™ Closing modal ${modalId} via click-outside`);
                            modal.remove();
                        }
                    };
                    modal.style.cursor = 'pointer';
                    const content = modal.querySelector('.modal-content');
                    if (content) {
                        content.style.cursor = 'default';
                        content.onclick = function(event) {
                            console.log(`üì¶ Content clicked, stopping propagation`);
                            event.stopPropagation();
                        };
                    }
                    console.log(`‚úÖ Click-outside functionality added to ${modalId}`);
                } else {
                    console.warn(`‚ö†Ô∏è Modal ${modalId} not found!`);
                }
            }, 300);
        };

        // Initialize the game when the page loads
        window.addEventListener('load', async () => {
            console.log('üöÄ Page loaded, starting initialization...');
            
            // Test buttons immediately
            setTimeout(() => {
                console.log('üîç Testing button existence...');
                const audioBtn = document.getElementById('audioControlBtn');
                const customBtn = document.getElementById('customizationBtn');
                const statsBtn = document.getElementById('statisticsBtn');
                const settingsBtn = document.getElementById('settingsBtn');
                
                console.log('Audio button:', audioBtn);
                console.log('Custom button:', customBtn);
                console.log('Stats button:', statsBtn);
                console.log('Settings button:', settingsBtn);
                
                // Add direct click handlers as a fallback
                if (audioBtn) {
                    audioBtn.onclick = function() {
                        console.log('üéµ DIRECT AUDIO CLICK!');
                        try {
                            if (window.gameInstance && window.gameInstance.showAudioModal) {
                                window.gameInstance.showAudioModal();
                                window.addClickOutsideToModal('audioModal');
                            } else {
                                console.log('‚è≥ Game instance not ready, retrying...');
                                setTimeout(() => {
                                    if (window.gameInstance && window.gameInstance.showAudioModal) {
                                        window.gameInstance.showAudioModal();
                                        window.addClickOutsideToModal('audioModal');
                                    }
                                }, 500);
                            }
                            console.log('‚úÖ Audio modal function called successfully');
                        } catch (error) {
                            console.error('‚ùå Error showing audio modal:', error);
                        }
                    };
                    console.log('‚úÖ Direct audio click handler added');
                }
                
                if (customBtn) {
                    customBtn.onclick = function() {
                        console.log('üé® DIRECT CUSTOM CLICK!');
                        try {
                            if (window.gameInstance && window.gameInstance.showCustomizationModal) {
                                window.gameInstance.showCustomizationModal();
                                window.addClickOutsideToModal('customizationModal');
                            } else {
                                console.log('‚è≥ Game instance not ready, retrying...');
                                setTimeout(() => {
                                    if (window.gameInstance && window.gameInstance.showCustomizationModal) {
                                        window.gameInstance.showCustomizationModal();
                                        window.addClickOutsideToModal('customizationModal');
                                    }
                                }, 500);
                            }
                            console.log('‚úÖ Customization modal function called successfully');
                        } catch (error) {
                            console.error('‚ùå Error showing customization modal:', error);
                        }
                    };
                    console.log('‚úÖ Direct custom click handler added');
                }
                
                if (statsBtn) {
                    statsBtn.onclick = function() {
                        console.log('üèÜ DIRECT STATS CLICK!');
                        try {
                            if (window.gameInstance && window.gameInstance.showStatisticsModal) {
                                window.gameInstance.showStatisticsModal();
                                window.addClickOutsideToModal('statisticsModal');
                            } else {
                                // Create statistics modal directly
                                const modalHTML = `
                                    <div class="modal-overlay active" id="statisticsModal" onclick="if(event.target === this) this.remove()" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.8); z-index: 9999; display: flex; align-items: center; justify-content: center; cursor: pointer;">
                                        <div class="modal-content" onclick="event.stopPropagation()" style="background: var(--bg-secondary); padding: 2rem; border-radius: 15px; color: var(--text-primary); max-width: 500px; width: 90%; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5); cursor: default; position: relative;">
                                            <button onclick="document.getElementById('statisticsModal').remove()" style="position: absolute; top: 1rem; right: 1rem; background: var(--accent-red); color: white; border: none; width: 40px; height: 40px; border-radius: 50%; cursor: pointer; font-size: 1.2rem; display: flex; align-items: center; justify-content: center; font-weight: bold;">√ó</button>
                                            <h2 style="margin-bottom: 1.5rem; color: var(--accent-green); padding-right: 3rem;">üèÜ Player Statistics</h2>
                                            
                                            <div style="display: grid; gap: 1rem; margin-bottom: 2rem;">
                                                <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; background: var(--bg-tertiary); border-radius: 8px;">
                                                    <span>üéÆ Games Played:</span>
                                                    <span style="font-weight: bold; color: var(--accent-green);">0</span>
                                                </div>
                                                <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; background: var(--bg-tertiary); border-radius: 8px;">
                                                    <span>üèÜ Games Won:</span>
                                                    <span style="font-weight: bold; color: var(--accent-green);">0</span>
                                                </div>
                                                <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; background: var(--bg-tertiary); border-radius: 8px;">
                                                    <span>üé≤ Total Dice Rolls:</span>
                                                    <span style="font-weight: bold; color: var(--accent-green);">0</span>
                                                </div>
                                                <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; background: var(--bg-tertiary); border-radius: 8px;">
                                                    <span>üêç Snakes Hit:</span>
                                                    <span style="font-weight: bold; color: var(--accent-red);">0</span>
                                                </div>
                                                <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; background: var(--bg-tertiary); border-radius: 8px;">
                                                    <span>ü™ú Ladders Climbed:</span>
                                                    <span style="font-weight: bold; color: var(--accent-blue);">0</span>
                                                </div>
                                            </div>
                                            
                                            <h3 style="margin-bottom: 1rem; color: var(--accent-orange);">üèÖ Achievements</h3>
                                            <div style="margin-bottom: 2rem;">
                                                <div style="padding: 0.5rem; color: var(--text-secondary);">üéØ First Game - Play your first game</div>
                                                <div style="padding: 0.5rem; color: var(--text-secondary);">üèÜ Victory - Win your first game</div>
                                                <div style="padding: 0.5rem; color: var(--text-secondary);">‚ö° Speed Demon - Win in under 20 rolls</div>
                                                <div style="padding: 0.5rem; color: var(--text-secondary);">üêç Snake Charmer - Hit 5 snakes total</div>
                                                <div style="padding: 0.5rem; color: var(--text-secondary);">ü™ú Climber - Climb 5 ladders total</div>
                                            </div>
                                            
                                            <button onclick="document.getElementById('statisticsModal').remove()" style="background: var(--accent-green); color: white; border: none; padding: 1rem 2rem; border-radius: 8px; cursor: pointer; font-size: 1rem; width: 100%;">Close</button>
                                        </div>
                                    </div>
                                `;
                                document.body.insertAdjacentHTML('beforeend', modalHTML);
                            }
                            console.log('‚úÖ Statistics modal shown successfully');
                        } catch (error) {
                            console.error('‚ùå Error showing statistics modal:', error);
                        }
                    };
                    console.log('‚úÖ Direct stats click handler added');
                }
                
                if (settingsBtn) {
                    settingsBtn.onclick = function() {
                        console.log('‚öôÔ∏è DIRECT SETTINGS CLICK!');
                        try {
                            if (window.gameInstance && window.gameInstance.showSettingsModal) {
                                window.gameInstance.showSettingsModal();
                                window.addClickOutsideToModal('settingsModal');
                            } else {
                                // Create settings modal directly
                                const modalHTML = `
                                    <div class="modal-overlay active" id="settingsModal" onclick="if(event.target === this) this.remove()" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.8); z-index: 9999; display: flex; align-items: center; justify-content: center; cursor: pointer;">
                                        <div class="modal-content" onclick="event.stopPropagation()" style="background: var(--bg-secondary); padding: 2rem; border-radius: 15px; color: var(--text-primary); max-width: 500px; width: 90%; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5); cursor: default; position: relative;">
                                            <button onclick="document.getElementById('settingsModal').remove()" style="position: absolute; top: 1rem; right: 1rem; background: var(--accent-red); color: white; border: none; width: 40px; height: 40px; border-radius: 50%; cursor: pointer; font-size: 1.2rem; display: flex; align-items: center; justify-content: center; font-weight: bold;">√ó</button>
                                            <h2 style="margin-bottom: 1.5rem; color: var(--accent-orange); padding-right: 3rem;">‚öôÔ∏è Game Settings</h2>
                                            
                                            <div style="margin-bottom: 1.5rem;">
                                                <h3 style="margin-bottom: 1rem;">Display Settings</h3>
                                                <div style="margin-bottom: 1rem;">
                                                    <label><input type="checkbox" checked> Show Animations</label>
                                                </div>
                                                <div style="margin-bottom: 1rem;">
                                                    <label><input type="checkbox" checked> Show Particle Effects</label>
                                                </div>
                                                <div style="margin-bottom: 1rem;">
                                                    <label><input type="checkbox" checked> Screen Shake Effects</label>
                                                </div>
                                            </div>
                                            
                                            <div style="margin-bottom: 1.5rem;">
                                                <h3 style="margin-bottom: 1rem;">Game Settings</h3>
                                                <div style="margin-bottom: 1rem;">
                                                    <label style="display: block; margin-bottom: 0.5rem;">Animation Speed:</label>
                                                    <select style="width: 100%; padding: 0.5rem; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary);">
                                                        <option>Slow</option>
                                                        <option selected>Normal</option>
                                                        <option>Fast</option>
                                                    </select>
                                                </div>
                                                <div style="margin-bottom: 1rem;">
                                                    <label><input type="checkbox" checked> Auto-roll dice</label>
                                                </div>
                                            </div>
                                            
                                            <div style="margin-bottom: 2rem;">
                                                <h3 style="margin-bottom: 1rem;">Data Management</h3>
                                                <button onclick="if(confirm('Clear all statistics and achievements?')){localStorage.clear(); alert('Data cleared!');}" style="background: var(--accent-red); color: white; border: none; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer; margin-right: 0.5rem;">Clear All Data</button>
                                                <button onclick="alert('Settings exported to console'); console.log('Game settings export not implemented yet');" style="background: var(--accent-blue); color: white; border: none; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer;">Export Settings</button>
                                            </div>
                                            
                                            <button onclick="document.getElementById('settingsModal').remove()" style="background: var(--accent-orange); color: white; border: none; padding: 1rem 2rem; border-radius: 8px; cursor: pointer; font-size: 1rem; width: 100%;">Close</button>
                                        </div>
                                    </div>
                                `;
                                document.body.insertAdjacentHTML('beforeend', modalHTML);
                            }
                            console.log('‚úÖ Settings modal shown successfully');
                        } catch (error) {
                            console.error('‚ùå Error showing settings modal:', error);
                        }
                    };
                    console.log('‚úÖ Direct settings click handler added');
                }
                
                // AI Bot button handler
                const aiBotBtn = document.getElementById('aiBotBtn');
                if (aiBotBtn) {
                    aiBotBtn.onclick = function() {
                        console.log('ü§ñ AI BOT BUTTON CLICKED!');
                        try {
                            if (window.gameInstance) {
                                // Only allow AI bots if not in a multiplayer room
                                if (window.gameInstance.roomId && window.gameInstance.roomId.length === 6) {
                                    alert('‚ö†Ô∏è AI bots are disabled in multiplayer rooms. Use this for solo practice only!');
                                    return;
                                }
                                
                                // Add an AI player
                                if (window.gameInstance.players.length < 4) {
                                    const aiNames = ['ü§ñ NeuralNet', '‚ö° CyberBot', 'üî• TurboAI', 'üöÄ MegaMind'];
                                    const unusedNames = aiNames.filter(name => 
                                        !window.gameInstance.players.find(p => p.name === name)
                                    );
                                    
                                    if (unusedNames.length > 0) {
                                        const aiName = unusedNames[0];
                                        const aiAddress = `0xAI${Date.now().toString(16).slice(-6)}`;
                                        window.gameInstance.addAIPlayer(aiName, aiAddress);
                                        alert(`‚úÖ ${aiName} joined the game! You can now practice with AI.`);
                                    } else {
                                        alert('‚ö†Ô∏è Maximum AI players already added!');
                                    }
                                } else {
                                    alert('‚ö†Ô∏è Game is full (maximum 4 players)!');
                                }
                            } else {
                                alert('‚ö†Ô∏è Game not initialized yet, please wait...');
                            }
                        } catch (error) {
                            console.error('‚ùå Error adding AI bot:', error);
                            alert('‚ùå Failed to add AI bot. Please try again.');
                        }
                    };
                    console.log('‚úÖ AI Bot button handler added');
                }
            }, 1000);
            
            // Initialize game instance
            try {
                window.gameInstance = new UltraModernSnakesAndLadders();
                console.log('‚úÖ Game instance created');
                await window.gameInstance.init();
                console.log('‚úÖ Game initialization complete');
            } catch (error) {
                console.error('‚ùå Game initialization failed:', error);
            }
            
            // Add global testing functions
            window.testButtons = () => {
                const buttons = ['audioControlBtn', 'customizationBtn', 'statisticsBtn', 'settingsBtn', 'aiBotBtn'];
                buttons.forEach(btnId => {
                    const btn = document.getElementById(btnId);
                    console.log(`Button ${btnId}:`, btn ? 'FOUND' : 'NOT FOUND', btn);
                });
            };
            
            window.testModalDirect = () => {
                console.log('Testing modal directly...');
                if (window.gameInstance) {
                    window.gameInstance.showAudioModal();
                } else {
                    console.log('Game instance not found');
                }
            };
            
            window.forceModalTest = () => {
                console.log('Force testing modal...');
                const modalHTML = `
                    <div class="modal-overlay active" id="testModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 9999; display: flex; align-items: center; justify-content: center;">
                        <div style="background: white; padding: 20px; border-radius: 10px; color: black;">
                            <h2>üéµ Test Modal</h2>
                            <p>This proves modals can appear!</p>
                            <button onclick="document.getElementById('testModal').remove()">Close</button>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
            };
        });

        // Cleanup when page unloads
        window.addEventListener('beforeunload', () => {
            if (window.gameInstance) {
                window.gameInstance.stopAIPreventionMonitor();
            }
        });
    </script>
</body>
</html>
